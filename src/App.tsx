import { useCallback, useEffect, useRef, useState } from 'react';
import { DropOverlay } from './components/DropOverlay';
import { ProcessingStatus } from './components/ProcessingStatus';
import { Toolbar } from './components/toolbar/Toolbar';
import { OverlaySidebar } from './components/OverlaySidebar';
import { SettingsModal } from './components/SettingsModal';
import { useApplicationConfig } from './hooks/useApplicationConfig';
import { useAutomationSettings } from './hooks/useAutomationSettings';
import { useSessionStorage } from './hooks/useSessionStorage';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { AdvancedControls } from './features/ocr/components/AdvancedControls';
import { OcrPreviewPanel } from './features/ocr/components/OcrPreviewPanel';
import { OcrTextPanel } from './features/ocr/components/OcrTextPanel';
import { useOcrProcessing } from './features/ocr/useOcrProcessing';
import { useImageGeneration } from './features/imageGeneration/useImageGeneration';
import { PromptGenerationPanel } from './features/promptOptimization/components/PromptGenerationPanel';
import { GeneratedImagePanel } from './features/promptOptimization/components/GeneratedImagePanel';
import { usePromptOptimization } from './features/promptOptimization/usePromptOptimization';
import type { AppSession, SessionSource } from './types/appSession';
import type { SortOption } from './components/OverlaySidebar';
import { open as openDialog } from '@tauri-apps/plugin-dialog';
import { exists as fsExists, remove as fsRemove } from '@tauri-apps/plugin-fs';
import './App.css';

// Optimized session array management utilities
const sortSessions = (sessions: AppSession[], sortBy: SortOption): AppSession[] => {
  return [...sessions].sort((a, b) => b[sortBy] - a[sortBy]);
};

// Insert session maintaining sort order - O(n) instead of O(n log n)
const insertSessionSorted = (
  sessions: AppSession[],
  newSession: AppSession,
  sortBy: SortOption
): AppSession[] => {
  const sortValue = newSession[sortBy];
  let insertIndex = 0;

  // Find insertion point (sessions are sorted descending)
  while (insertIndex < sessions.length && sessions[insertIndex][sortBy] > sortValue) {
    insertIndex++;
  }

  const result = [...sessions];
  result.splice(insertIndex, 0, newSession);
  return result;
};

// Update session and reposition if needed - avoids full sort
const updateSessionInPlace = (
  sessions: AppSession[],
  sessionId: string,
  updater: (session: AppSession) => AppSession,
  sortBy: SortOption
): AppSession[] => {
  const index = sessions.findIndex(s => s.id === sessionId);
  if (index === -1) return sessions;

  const updated = updater(sessions[index]);
  const newSortValue = updated[sortBy];

  // Check if position needs to change
  const needsReposition =
    (index > 0 && sessions[index - 1][sortBy] < newSortValue) ||
    (index < sessions.length - 1 && sessions[index + 1][sortBy] > newSortValue);

  if (!needsReposition) {
    // Simple in-place update
    const result = [...sessions];
    result[index] = updated;
    return result;
  }

  // Remove and reinsert
  const withoutSession = sessions.filter(s => s.id !== sessionId);
  return insertSessionSorted(withoutSession, updated, sortBy);
};

const App = () => {
  const [showAdvanced, setShowAdvanced] = useState<boolean>(false);
  const [hasPerformedOcr, setHasPerformedOcr] = useState<boolean>(false);
  const [isSidebarOpen, setIsSidebarOpen] = useState<boolean>(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState<boolean>(false);
  const { sessions, setSessions, isLoading: isSessionsLoading } = useSessionStorage();
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const [sortBy, setSortBy] = useState<SortOption>('updatedAt');
  const suppressAutoProcessRef = useRef<boolean>(false);
  const suppressPromptResetRef = useRef<boolean>(false);
  const isRestoringSessionRef = useRef<boolean>(false);
  const lastAutoOptimizedOcrRef = useRef<string>('');
  const lastAutoPromptRef = useRef<string>('');
  const lastAutoGeneratedImageRef = useRef<string>('');
  const lastAutoSavedImageRef = useRef<string>('');
  const onNewImageHandlerRef = useRef<((details: { path: string; previewUrl: string; source: 'file' | 'drop' | 'screenshot'; }) => string) | null>(null);
  const imagePathToSessionIdRef = useRef<Map<string, { sessionId: string; timestamp: number }>>(new Map());
  const MAX_MAPPING_ENTRIES = 100;
  const MAPPING_MAX_AGE_MS = 5 * 60 * 1000; // 5 minutes
  const optimizeOcrTextRef = useRef<(() => Promise<void>) | null>(null);

  const {
    llmSettings,
    updateLLMSetting,
    bflApiKey,
    setBflApiKey,
    geminiApiKey,
    setGeminiApiKey,
    bltcyApiKey,
    setBltcyApiKey,
    selectedModel,
    setSelectedModel
  } = useApplicationConfig();
  const {
    settings: automationSettings,
    updateSetting: updateAutomationSetting,
    isLoading: isAutomationLoading
  } = useAutomationSettings();

  const {
    aspectRatio,
    setAspectRatio,
    generatedImageUrl,
    generatedImageRemoteUrl,
    generatedImageLocalPath,
    isGenerating,
    generationStatus,
    generateImage,
    saveGeneratedImage,
    copyGeneratedImageUrl,
    copyGeneratedImageToClipboard,
    clearGeneratedImage,
    saveGeneratedImageToDirectory,
    loadSessionSnapshot: loadGenerationSnapshot
  } = useImageGeneration({ bflApiKey, geminiApiKey, bltcyApiKey, selectedModel });

  const deleteSessionImageFile = useCallback(async (filePath: string) => {
    if (!filePath) {
      return;
    }

    try {
      const fileExists = await fsExists(filePath);
      if (fileExists) {
        await fsRemove(filePath);
      }
    } catch (error) {
      console.warn('Failed to delete generated image file:', filePath, error);
    }
  }, []);

  // Cleanup stale mapping entries
  const cleanupStaleMappings = useCallback(() => {
    const now = Date.now();
    const map = imagePathToSessionIdRef.current;

    for (const [path, entry] of map.entries()) {
      if (now - entry.timestamp > MAPPING_MAX_AGE_MS) {
        map.delete(path);
      }
    }

    // If still over capacity, remove oldest entries
    if (map.size > MAX_MAPPING_ENTRIES) {
      const entries = Array.from(map.entries())
        .sort((a, b) => a[1].timestamp - b[1].timestamp);

      const toRemove = entries.slice(0, map.size - MAX_MAPPING_ENTRIES);
      toRemove.forEach(([path]) => map.delete(path));
    }
  }, [MAX_MAPPING_ENTRIES, MAPPING_MAX_AGE_MS]);

  const handleOcrComplete = useCallback((details: { imagePath: string; ocrText: string; processedImageUrl: string; }) => {
    // Find the session ID for this image path
    const entry = imagePathToSessionIdRef.current.get(details.imagePath);
    if (!entry) {
      console.warn('No session found for image path:', details.imagePath);
      return;
    }
    const sessionId = entry.sessionId;

    // Update hasPerformedOcr if this is the active session
    if (sessionId === activeSessionId) {
      setHasPerformedOcr(true);
    }

    // Update the session directly with OCR results
    // Keep the params from the session (including language setting)
    setSessions(prev => updateSessionInPlace(prev, sessionId, session => ({
      ...session,
      updatedAt: Date.now(),
      ocr: {
        ...session.ocr,
        processedImageUrl: details.processedImageUrl,
        ocrText: details.ocrText,
        // 清空optimizedText，防止旧内容残留
        optimizedText: '',
        textDisplayMode: 'original' as const
        // params remains from session.ocr.params - no change needed
      }
    }), sortBy));

    // 自动优化：只对当前活动session触发，以确保state正确同步
    if (sessionId === activeSessionId && automationSettings.autoOptimizeOcr && details.ocrText.trim() && !isRestoringSessionRef.current) {
      // Mark this text as being optimized to prevent duplicate optimization
      lastAutoOptimizedOcrRef.current = details.ocrText;
      // Use the hook's optimizeOcrText function to ensure all state updates are synchronized
      void optimizeOcrTextRef.current?.();
    }

    // 自动生成prompt:如果这是当前active session且开启了auto-generate prompt
    if (sessionId === activeSessionId && automationSettings.autoGeneratePrompt && details.ocrText.trim() && !isRestoringSessionRef.current) {
      // Reset the lastAutoPromptRef to allow auto-generation for the new image
      lastAutoPromptRef.current = '';
    }

    // Clean up the mapping
    imagePathToSessionIdRef.current.delete(details.imagePath);
  }, [activeSessionId, automationSettings.autoOptimizeOcr, automationSettings.autoGeneratePrompt, setSessions, sortBy]);

  const handleOptimizeComplete = useCallback((details: { imagePath: string; optimizedText: string; }) => {
    // Find the session for this image path
    setSessions(prev => {
      const session = prev.find(s => s.ocr.imagePath === details.imagePath);
      if (!session) return prev;

      return updateSessionInPlace(prev, session.id, s => ({
        ...s,
        updatedAt: Date.now(),
        ocr: {
          ...s.ocr,
          optimizedText: details.optimizedText,
          textDisplayMode: 'optimized' as const
        }
      }), sortBy);
    });
  }, [sortBy]);

  const handleOcrError = useCallback((details: { imagePath: string; error: string; }) => {
    // Clean up the mapping to prevent memory leak
    imagePathToSessionIdRef.current.delete(details.imagePath);
    console.error('OCR processing failed:', details.error, 'for image:', details.imagePath);
  }, []);

  const {
    imagePath,
    imagePreviewUrl,
    processedImageUrl,
    ocrText,
    updateOcrText,
    optimizedText,
    updateOptimizedText,
    isOptimizingText,
    textDisplayMode,
    setTextDisplayMode,
    optimizeOcrText,
    isProcessing,
    processingStatus,
    params,
    updateParam,
    selectImage,
    takeScreenshot,
    performOCR,
    copyOcrText,
    saveOcrText,
    isDragging,
    dragAndDropHandlers,
    loadSessionSnapshot: loadOcrSnapshot
  } = useOcrProcessing({
    llmSettings,
    suppressAutoProcessRef,
    onNewImage: (details) => {
      return onNewImageHandlerRef.current?.(details) ?? '';
    },
    onOcrComplete: handleOcrComplete,
    onOcrError: handleOcrError,
    onOptimizeComplete: handleOptimizeComplete
  });

  const {
    imageStyle,
    customDescription,
    optimizedPrompt,
    isOptimizing,
    llmError,
    setImageStyle,
    setCustomDescription,
    setOptimizedPrompt,
    optimizePrompt,
    loadSessionSnapshot: loadPromptSnapshot
  } = usePromptOptimization(llmSettings, ocrText, {
    suppressOcrResetRef: suppressPromptResetRef
  });

  const generateSessionId = useCallback(() => {
    if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
      return crypto.randomUUID();
    }
    return `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }, []);

  const deriveSessionTitle = useCallback((path: string, source: SessionSource) => {
    if (path) {
      const parts = path.split(/[/\\]/);
      const filename = parts[parts.length - 1];
      if (filename) {
        return filename;
      }
    }

    const timestamp = new Date().toLocaleTimeString();
    switch (source) {
      case 'screenshot':
        return `Screenshot ${timestamp}`;
      case 'drop':
        return `Drag & Drop ${timestamp}`;
      default:
        return `Session ${timestamp}`;
    }
  }, []);

  const handleNewImage = useCallback((details: { path: string; previewUrl: string; source: SessionSource; }) => {
    const sessionId = generateSessionId();
    const timestamp = Date.now();
    const newSession: AppSession = {
      id: sessionId,
      title: deriveSessionTitle(details.path, details.source),
      createdAt: timestamp,
      updatedAt: timestamp,
      source: details.source,
      ocr: {
        imagePath: details.path,
        imagePreviewUrl: details.previewUrl,
        processedImageUrl: '',
        ocrText: '',
        optimizedText: '',
        textDisplayMode: 'original',
        params
      },
      prompt: {
        imageStyle,
        customDescription,
        optimizedPrompt: ''
      },
      generation: {
        aspectRatio,
        generatedImageUrl: '',
        generatedImageRemoteUrl: '',
        generatedImageLocalPath: ''
      }
    };

    setSessions(prev => insertSessionSorted(prev, newSession, sortBy));
    setActiveSessionId(sessionId);
    setHasPerformedOcr(false);

    // Track the mapping from image path to session ID with timestamp
    // Clean up old entries before adding new one
    cleanupStaleMappings();
    imagePathToSessionIdRef.current.set(details.path, {
      sessionId,
      timestamp: Date.now()
    });

    lastAutoOptimizedOcrRef.current = '';
    lastAutoPromptRef.current = '';
    lastAutoGeneratedImageRef.current = '';
    lastAutoSavedImageRef.current = '';

    // Return the session ID so caller can update the session later
    return sessionId;
  }, [aspectRatio, cleanupStaleMappings, customDescription, deriveSessionTitle, generateSessionId, imageStyle, params, sortBy]);

  useEffect(() => {
    onNewImageHandlerRef.current = handleNewImage;
  }, [handleNewImage]);

  useEffect(() => {
    optimizeOcrTextRef.current = optimizeOcrText;
  }, [optimizeOcrText]);

  // Cleanup mapping table on unmount
  useEffect(() => {
    return () => {
      imagePathToSessionIdRef.current.clear();
    };
  }, []);

  // Re-sort sessions when sortBy changes
  // Note: This only triggers when user explicitly changes sort option
  // Performance: O(n log n) but n is typically small (<50 sessions)
  useEffect(() => {
    setSessions(prev => {
      // Avoid unnecessary re-sort if already sorted by this criterion
      // Check if first two elements are in correct order (heuristic)
      if (prev.length >= 2 && prev[0][sortBy] >= prev[1][sortBy]) {
        // Likely already sorted, but verify with full check
        const isSorted = prev.every((session, i) =>
          i === 0 || prev[i - 1][sortBy] >= session[sortBy]
        );
        if (isSorted) {
          return prev; // No need to re-sort
        }
      }
      return sortSessions(prev, sortBy);
    });
  }, [sortBy, setSessions]);

  // Auto-optimize when setting is enabled and OCR text exists without optimization
  // This works in conjunction with handleOcrComplete to support two scenarios:
  // 1. Auto-optimize on OCR completion (handled in handleOcrComplete)
  // 2. Auto-optimize when user enables the setting after OCR is complete (handled here)
  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoOptimizeOcr || !ocrText.trim() || isRestoringSessionRef.current || isOptimizingText) {
      return;
    }

    // Only auto-optimize if there's no optimized text yet
    // This prevents duplicate optimization when handleOcrComplete already optimized
    if (optimizedText.trim()) {
      return;
    }

    if (lastAutoOptimizedOcrRef.current === ocrText) {
      return;
    }

    lastAutoOptimizedOcrRef.current = ocrText;
    void optimizeOcrText();
  }, [automationSettings.autoOptimizeOcr, isAutomationLoading, isOptimizingText, ocrText, optimizedText, optimizeOcrText]);

  // Update the active session's OCR state
  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update session state while optimization is in progress
    // This prevents saving incomplete/incorrect optimization results
    if (isOptimizingText) {
      return;
    }

    setSessions(prev => {
      if (!prev.find(s => s.id === activeSessionId)) {
        return prev;
      }

      return updateSessionInPlace(prev, activeSessionId, session => ({
        ...session,
        updatedAt: Date.now(),
        ocr: {
          imagePath,
          imagePreviewUrl,
          processedImageUrl,
          ocrText,
          optimizedText,
          textDisplayMode,
          params
        }
      }), sortBy);
    });
    // Note: isRestoringSessionRef excluded from deps - refs don't trigger re-renders
    // We read .current value inside the effect instead
  }, [activeSessionId, imagePath, imagePreviewUrl, processedImageUrl, ocrText, optimizedText, textDisplayMode, params, isOptimizingText, isSessionsLoading, setSessions, sortBy]);

  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update while optimization is in progress
    if (isOptimizing) {
      return;
    }

    setSessions(prev => {
      if (!prev.find(s => s.id === activeSessionId)) {
        return prev;
      }

      return updateSessionInPlace(prev, activeSessionId, session => ({
        ...session,
        updatedAt: Date.now(),
        prompt: {
          imageStyle,
          customDescription,
          optimizedPrompt
        }
      }), sortBy);
    });
    // Note: isRestoringSessionRef excluded from deps - refs don't trigger re-renders
  }, [activeSessionId, imageStyle, customDescription, optimizedPrompt, isOptimizing, isSessionsLoading, setSessions, sortBy]);

  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update while generation is in progress
    if (isGenerating) {
      return;
    }

    setSessions(prev => {
      if (!prev.find(s => s.id === activeSessionId)) {
        return prev;
      }

      return updateSessionInPlace(prev, activeSessionId, session => ({
        ...session,
        updatedAt: Date.now(),
        generation: {
          aspectRatio,
          generatedImageUrl: '',
          generatedImageRemoteUrl,
          generatedImageLocalPath
        }
      }), sortBy);
    });
    // Note: isRestoringSessionRef excluded from deps - refs don't trigger re-renders
  }, [
    activeSessionId,
    aspectRatio,
    generatedImageLocalPath,
    generatedImageRemoteUrl,
    isGenerating,
    isSessionsLoading,
    setSessions,
    sortBy
  ]);

  // Track OCR state changes
  const previousOcrText = useRef<string>('');
  useEffect(() => {
    // Don't reset prompt when restoring a session
    if (isRestoringSessionRef.current) {
      return;
    }

    if (previousOcrText.current !== ocrText) {
      // OCR text changed - mark as performed if not empty
      if (ocrText) {
        setHasPerformedOcr(true);
      }

      // Reset prompt when OCR text changes, but keep the generated image
      // Users may want to keep the generated image even if OCR text changes
      if (previousOcrText.current) {
        setOptimizedPrompt('');
        // Don't reset generation state - let users manually clear if needed
      }

      previousOcrText.current = ocrText;
    }
    // Note: isRestoringSessionRef, previousOcrText excluded from deps
    // Refs don't trigger re-renders, we read .current inside effect
  }, [ocrText, setOptimizedPrompt]);

  const handleGenerateImage = useCallback(() => {
    if (!optimizedPrompt.trim()) {
      return;
    }
    lastAutoGeneratedImageRef.current = optimizedPrompt;
    void generateImage(optimizedPrompt);
  }, [generateImage, optimizedPrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGeneratePrompt || !ocrText.trim() || isRestoringSessionRef.current || isOptimizing) {
      return;
    }

    if (lastAutoPromptRef.current === ocrText) {
      return;
    }

    lastAutoPromptRef.current = ocrText;
    void optimizePrompt();
  }, [automationSettings.autoGeneratePrompt, isAutomationLoading, isOptimizing, ocrText, optimizePrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGenerateImage || !optimizedPrompt.trim() || isRestoringSessionRef.current || isGenerating) {
      return;
    }

    if (lastAutoGeneratedImageRef.current === optimizedPrompt) {
      return;
    }

    lastAutoGeneratedImageRef.current = optimizedPrompt;
    void generateImage(optimizedPrompt);
  }, [automationSettings.autoGenerateImage, generateImage, isAutomationLoading, isGenerating, optimizedPrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoSaveImage ||
        !automationSettings.autoSaveDirectory.trim() ||
        !generatedImageUrl ||
        isRestoringSessionRef.current) {
      return;
    }

    if (lastAutoSavedImageRef.current === generatedImageUrl) {
      return;
    }

    lastAutoSavedImageRef.current = generatedImageUrl;
    void saveGeneratedImageToDirectory(automationSettings.autoSaveDirectory).catch(() => {
      // Error already surfaced via generation status; no-op here.
    });
  }, [
    automationSettings.autoSaveDirectory,
    automationSettings.autoSaveImage,
    generatedImageUrl,
    isAutomationLoading,
    saveGeneratedImageToDirectory
  ]);

  const handleCopyPrompt = () => {
    if (!optimizedPrompt.trim()) {
      return;
    }

    navigator.clipboard.writeText(optimizedPrompt).catch(error => {
      console.error('Failed to copy optimized prompt:', error);
    });
  };

  const handleSelectAutoSaveDirectory = useCallback(async () => {
    try {
      const selected = await openDialog({
        directory: true,
        multiple: false,
        defaultPath: automationSettings.autoSaveDirectory || undefined
      });

      if (typeof selected === 'string' && selected.trim()) {
        updateAutomationSetting('autoSaveDirectory', selected);
      }
    } catch (error) {
      console.error('Failed to select auto-save directory:', error);
    }
  }, [automationSettings.autoSaveDirectory, updateAutomationSetting]);

  const handleLanguageChange = (language: string) => {
    updateParam('language', language);
  };

  const toggleAdvanced = () => setShowAdvanced(prev => !prev);

  const gridClassName = 'main-content-three-column has-generated';

  useKeyboardShortcuts({
    onSelectImage: () => { void selectImage(); },
    onTakeScreenshot: () => { void takeScreenshot(); },
    onPerformOcr: () => { void performOCR(); },
    onCopyText: () => { void copyOcrText(); },
    onSaveText: () => { void saveOcrText(); },
    onToggleAdvanced: toggleAdvanced,
    onOpenSettings: () => setIsSettingsOpen(true),
    canPerformOcr: Boolean(imagePath),
    hasOcrText: Boolean(ocrText.trim())
  });

  const handleSelectSession = useCallback((sessionId: string) => {
    if (sessionId === activeSessionId) {
      setIsSidebarOpen(false);
      return;
    }

    const session = sessions.find(item => item.id === sessionId);
    if (!session) {
      return;
    }

    // Prevent switching while already restoring
    if (isRestoringSessionRef.current) {
      console.log('Session restore already in progress, ignoring click');
      return;
    }

    const restoreSession = async () => {
      isRestoringSessionRef.current = true;
      suppressAutoProcessRef.current = true;
      suppressPromptResetRef.current = true;

      try {
        // First set the active session ID before loading snapshots
        // This ensures the effects know which session is being restored
        setActiveSessionId(sessionId);

        // Wait for all snapshot loading operations to complete
        // This ensures state is fully synchronized before resetting flags
        await Promise.all([
          Promise.resolve(loadOcrSnapshot(session.ocr)),
          Promise.resolve(loadPromptSnapshot(session.prompt)),
          loadGenerationSnapshot(session.generation)
        ]);

        // Check if session has any OCR data (text or processed image)
        const hasOcrData = Boolean(session.ocr.ocrText || session.ocr.processedImageUrl);
        setHasPerformedOcr(hasOcrData);

        setSessions(prev => updateSessionInPlace(prev, sessionId, session => ({
          ...session,
          updatedAt: Date.now()
        }), sortBy));

        // Wait for next tick to ensure all setState calls have been processed
        await new Promise(resolve => setTimeout(resolve, 0));
      } finally {
        // Reset flags after all async operations complete
        suppressAutoProcessRef.current = false;
        suppressPromptResetRef.current = false;
        isRestoringSessionRef.current = false;
      }
    };

    void restoreSession();
    setIsSidebarOpen(false);
  }, [
    activeSessionId,
    sessions,
    loadOcrSnapshot,
    loadPromptSnapshot,
    loadGenerationSnapshot,
    suppressAutoProcessRef,
    suppressPromptResetRef,
    sortBy
  ]);

  const handleDeleteSession = useCallback((sessionId: string) => {
    setSessions(prev => {
      const sessionToDelete = prev.find(session => session.id === sessionId);
      if (sessionToDelete?.generation.generatedImageLocalPath) {
        void deleteSessionImageFile(sessionToDelete.generation.generatedImageLocalPath);
      }
      return prev.filter(session => session.id !== sessionId);
    });

    // If we deleted the active session, clear the active session
    if (sessionId === activeSessionId) {
      setActiveSessionId(null);
      setHasPerformedOcr(false);
      clearGeneratedImage();
    }
  }, [activeSessionId, clearGeneratedImage, deleteSessionImageFile, setSessions]);

  return (
    <div
      className="container"
      {...dragAndDropHandlers}
    >
      <h1>Imagio</h1>

      <div className="shortcuts-hint">
        ⌨️ Shortcuts: <kbd>⌘O</kbd> Open | <kbd>⌘⇧S</kbd> Screenshot | <kbd>⌘C</kbd> Copy | <kbd>⌘S</kbd> Save | <kbd>⌘,</kbd> Settings
      </div>

      <DropOverlay isVisible={isDragging} />

      <OverlaySidebar
        isOpen={isSidebarOpen}
        onClose={() => setIsSidebarOpen(false)}
        automationSettings={automationSettings}
        onAutomationSettingChange={updateAutomationSetting}
        onSelectAutoSaveDirectory={() => { void handleSelectAutoSaveDirectory(); }}
        sessions={sessions}
        activeSessionId={activeSessionId}
        onSelectSession={handleSelectSession}
        onDeleteSession={handleDeleteSession}
        onOpenSettings={() => {
          setIsSidebarOpen(false);
          setIsSettingsOpen(true);
        }}
        sortBy={sortBy}
        onSortByChange={setSortBy}
      />

      <SettingsModal
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        llmSettings={llmSettings}
        onLLMSettingChange={updateLLMSetting}
        bflApiKey={bflApiKey}
        onBflApiKeyChange={setBflApiKey}
        geminiApiKey={geminiApiKey}
        onGeminiApiKeyChange={setGeminiApiKey}
        bltcyApiKey={bltcyApiKey}
        onBltcyApiKeyChange={setBltcyApiKey}
        selectedModel={selectedModel}
        onSelectedModelChange={setSelectedModel}
      />

      <Toolbar
        onSelectImage={() => { void selectImage(); }}
        onTakeScreenshot={() => { void takeScreenshot(); }}
        language={params.language}
        onLanguageChange={handleLanguageChange}
        showAdvanced={showAdvanced}
        onToggleAdvanced={toggleAdvanced}
        onToggleSidebar={() => setIsSidebarOpen(true)}
      />

      {showAdvanced && (
        <AdvancedControls
          params={params}
          onParamChange={updateParam}
        />
      )}

      <ProcessingStatus isProcessing={isProcessing} statusMessage={processingStatus} />

      {imagePath && (
        <div className={gridClassName}>
          <div className="left-panel">
            <OcrPreviewPanel
              imagePreviewUrl={imagePreviewUrl}
              processedImageUrl={processedImageUrl}
            />
          </div>

          <div className="middle-panel">
            {hasPerformedOcr && (
              <OcrTextPanel
                value={ocrText}
                onChange={updateOcrText}
                onCopy={() => copyOcrText()}
                onSave={() => saveOcrText()}
                optimizedText={optimizedText}
                isOptimizing={isOptimizingText}
                onOptimize={optimizeOcrText}
                textDisplayMode={textDisplayMode}
                onTextDisplayModeChange={setTextDisplayMode}
                onOptimizedTextChange={updateOptimizedText}
              />
            )}
          </div>

          {hasPerformedOcr && (
            <>
              <div className="right-panel">
                <PromptGenerationPanel
                  imageStyle={imageStyle}
                  onImageStyleChange={setImageStyle}
                  aspectRatio={aspectRatio}
                  onAspectRatioChange={setAspectRatio}
                  customDescription={customDescription}
                  onCustomDescriptionChange={setCustomDescription}
                  optimizedPrompt={optimizedPrompt}
                  onOptimizedPromptChange={setOptimizedPrompt}
                  onOptimize={optimizePrompt}
                  isOptimizing={isOptimizing}
                  llmError={llmError}
                  isOptimizeDisabled={!ocrText.trim()}
                  onCopyPrompt={handleCopyPrompt}
                  onGenerateImage={handleGenerateImage}
                  isGenerating={isGenerating}
                />
              </div>

              <div className="generated-panel">
                <GeneratedImagePanel
                  generatedImageUrl={generatedImageUrl}
                  isGenerating={isGenerating}
                  generationStatus={generationStatus}
                  onSaveGeneratedImage={() => saveGeneratedImage()}
                  onCopyGeneratedImage={() => copyGeneratedImageToClipboard()}
                  onCopyGeneratedImageUrl={() => copyGeneratedImageUrl()}
                  onClearGeneratedImage={clearGeneratedImage}
                  hasRemoteImageUrl={Boolean(generatedImageRemoteUrl)}
                />
              </div>
            </>
          )}
        </div>
      )}
    </div>
  );
};

export default App;
