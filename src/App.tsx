import { useCallback, useEffect, useRef, useState } from 'react';
import { DropOverlay } from './components/DropOverlay';
import { ProcessingStatus } from './components/ProcessingStatus';
import { Toolbar } from './components/toolbar/Toolbar';
import { OverlaySidebar } from './components/OverlaySidebar';
import { SettingsModal } from './components/SettingsModal';
import { useApplicationConfig } from './hooks/useApplicationConfig';
import { useAutomationSettings } from './hooks/useAutomationSettings';
import { useSessionStorage } from './hooks/useSessionStorage';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { AdvancedControls } from './features/ocr/components/AdvancedControls';
import { OcrPreviewPanel } from './features/ocr/components/OcrPreviewPanel';
import { OcrTextPanel } from './features/ocr/components/OcrTextPanel';
import { useOcrProcessing } from './features/ocr/useOcrProcessing';
import { useImageGeneration } from './features/imageGeneration/useImageGeneration';
import { PromptGenerationPanel } from './features/promptOptimization/components/PromptGenerationPanel';
import { GeneratedImagePanel } from './features/promptOptimization/components/GeneratedImagePanel';
import { usePromptOptimization } from './features/promptOptimization/usePromptOptimization';
import type { AppSession, SessionSource } from './types/appSession';
import type { SortOption } from './components/OverlaySidebar';
import { open as openDialog } from '@tauri-apps/plugin-dialog';
import './App.css';

const App = () => {
  const [showAdvanced, setShowAdvanced] = useState<boolean>(false);
  const [hasPerformedOcr, setHasPerformedOcr] = useState<boolean>(false);
  const [isSidebarOpen, setIsSidebarOpen] = useState<boolean>(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState<boolean>(false);
  const { sessions, setSessions, isLoading: isSessionsLoading } = useSessionStorage();
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const [sortBy, setSortBy] = useState<SortOption>('updatedAt');
  const suppressAutoProcessRef = useRef<boolean>(false);
  const suppressPromptResetRef = useRef<boolean>(false);
  const isRestoringSessionRef = useRef<boolean>(false);
  const lastAutoOptimizedOcrRef = useRef<string>('');
  const lastAutoPromptRef = useRef<string>('');
  const lastAutoGeneratedImageRef = useRef<string>('');
  const lastAutoSavedImageRef = useRef<string>('');
  const onNewImageHandlerRef = useRef<((details: { path: string; previewUrl: string; source: 'file' | 'drop' | 'screenshot'; }) => string) | null>(null);
  const imagePathToSessionIdRef = useRef<Map<string, string>>(new Map());

  const {
    llmSettings,
    updateLLMSetting,
    bflApiKey,
    setBflApiKey
  } = useApplicationConfig();
  const {
    settings: automationSettings,
    updateSetting: updateAutomationSetting,
    isLoading: isAutomationLoading
  } = useAutomationSettings();

  const {
    aspectRatio,
    setAspectRatio,
    generatedImageUrl,
    generatedImageRemoteUrl,
    isGenerating,
    generationStatus,
    generateImage,
    saveGeneratedImage,
    copyGeneratedImageUrl,
    copyGeneratedImageToClipboard,
    clearGeneratedImage,
    saveGeneratedImageToDirectory,
    loadSessionSnapshot: loadGenerationSnapshot
  } = useImageGeneration({ bflApiKey });

  const handleOcrComplete = useCallback((details: { imagePath: string; ocrText: string; processedImageUrl: string; }) => {
    // Find the session ID for this image path
    const sessionId = imagePathToSessionIdRef.current.get(details.imagePath);
    if (!sessionId) {
      console.warn('No session found for image path:', details.imagePath);
      return;
    }

    // Update hasPerformedOcr if this is the active session
    if (sessionId === activeSessionId) {
      setHasPerformedOcr(true);
    }

    // Update the session directly with OCR results
    // Keep the params from the session (including language setting)
    setSessions(prev => {
      const next = prev.map(session => {
        if (session.id !== sessionId) {
          return session;
        }
        return {
          ...session,
          updatedAt: Date.now(),
          ocr: {
            ...session.ocr,
            processedImageUrl: details.processedImageUrl,
            ocrText: details.ocrText,
            // 清空optimizedText，防止旧内容残留
            optimizedText: '',
            textDisplayMode: 'original' as const
            // params remains from session.ocr.params - no change needed
          }
        };
      });
      return [...next].sort((a, b) => b[sortBy] - a[sortBy]);
    });

    // 自动优化：每个session独立触发
    if (automationSettings.autoOptimizeOcr && details.ocrText.trim() && llmSettings && !isRestoringSessionRef.current) {
      // 直接调用优化API，传递当前imagePath和ocrText
      (async () => {
        try {
          let accumulatedText = '';
          await import('./utils/llmClient').then(({ callChatCompletionStream }) =>
            callChatCompletionStream({
              baseUrl: llmSettings.apiBaseUrl,
              model: llmSettings.modelName,
              apiKey: llmSettings.apiKey,
              temperature: llmSettings.temperature,
              maxTokens: 8000,
              reasoningEffort: 'minimal',
              messages: [
                { role: 'system', content: 'Clean and correct OCR text errors. Remove invalid characters, fix common OCR mistakes, keep original meaning. Return only the corrected text.' },
                { role: 'user', content: details.ocrText }
              ]
            }, (chunk: any) => {
              if (!chunk.isDone && chunk.content) {
                accumulatedText += chunk.content;
              }
            })
          );
          if (accumulatedText.trim()) {
            // 优化完成后，更新对应session
            setSessions(prev => {
              const next = prev.map(session => {
                if (session.id !== sessionId) return session;
                return {
                  ...session,
                  updatedAt: Date.now(),
                  ocr: {
                    ...session.ocr,
                    optimizedText: accumulatedText,
                    textDisplayMode: 'optimized' as const
                  }
                };
              });
              return [...next].sort((a, b) => b[sortBy] - a[sortBy]);
            });
          }
        } catch (error) {
          // 失败时不影响主流程
          setSessions(prev => {
            const next = prev.map(session => {
              if (session.id !== sessionId) return session;
              return {
                ...session,
                updatedAt: Date.now(),
                ocr: {
                  ...session.ocr,
                  optimizedText: `Error: ${error instanceof Error ? error.message : String(error)}`,
                  textDisplayMode: 'original' as const
                }
              };
            });
            return [...next].sort((a, b) => b[sortBy] - a[sortBy]);
          });
        }
      })();
    }

    // 自动生成prompt:如果这是当前active session且开启了auto-generate prompt
    if (sessionId === activeSessionId && automationSettings.autoGeneratePrompt && details.ocrText.trim() && !isRestoringSessionRef.current) {
      // Reset the lastAutoPromptRef to allow auto-generation for the new image
      lastAutoPromptRef.current = '';
    }

    // Clean up the mapping
    imagePathToSessionIdRef.current.delete(details.imagePath);
  }, [activeSessionId, automationSettings.autoOptimizeOcr, automationSettings.autoGeneratePrompt, llmSettings, sortBy]);

  const handleOptimizeComplete = useCallback((details: { imagePath: string; optimizedText: string; }) => {
    // Find the session for this image path
    setSessions(prev => {
      const next = prev.map(session => {
        if (session.ocr.imagePath !== details.imagePath) {
          return session;
        }
        return {
          ...session,
          updatedAt: Date.now(),
          ocr: {
            ...session.ocr,
            optimizedText: details.optimizedText,
            textDisplayMode: 'optimized' as const
          }
        };
      });
      return [...next].sort((a, b) => b[sortBy] - a[sortBy]);
    });
  }, []);

  const handleOcrError = useCallback((details: { imagePath: string; error: string; }) => {
    // Clean up the mapping to prevent memory leak
    imagePathToSessionIdRef.current.delete(details.imagePath);
    console.error('OCR processing failed:', details.error, 'for image:', details.imagePath);
  }, []);

  const {
    imagePath,
    imagePreviewUrl,
    processedImageUrl,
    ocrText,
    updateOcrText,
    optimizedText,
    updateOptimizedText,
    isOptimizingText,
    textDisplayMode,
    setTextDisplayMode,
    optimizeOcrText,
    isProcessing,
    processingStatus,
    params,
    updateParam,
    selectImage,
    takeScreenshot,
    performOCR,
    copyOcrText,
    saveOcrText,
    isDragging,
    dragAndDropHandlers,
    loadSessionSnapshot: loadOcrSnapshot
  } = useOcrProcessing({
    llmSettings,
    suppressAutoProcessRef,
    onNewImage: (details) => {
      return onNewImageHandlerRef.current?.(details) ?? '';
    },
    onOcrComplete: handleOcrComplete,
    onOcrError: handleOcrError,
    onOptimizeComplete: handleOptimizeComplete
  });

  const {
    imageStyle,
    customDescription,
    optimizedPrompt,
    isOptimizing,
    llmError,
    setImageStyle,
    setCustomDescription,
    setOptimizedPrompt,
    optimizePrompt,
    loadSessionSnapshot: loadPromptSnapshot
  } = usePromptOptimization(llmSettings, ocrText, {
    suppressOcrResetRef: suppressPromptResetRef
  });

  const generateSessionId = useCallback(() => {
    if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
      return crypto.randomUUID();
    }
    return `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }, []);

  const deriveSessionTitle = useCallback((path: string, source: SessionSource) => {
    if (path) {
      const parts = path.split(/[/\\]/);
      const filename = parts[parts.length - 1];
      if (filename) {
        return filename;
      }
    }

    const timestamp = new Date().toLocaleTimeString();
    switch (source) {
      case 'screenshot':
        return `Screenshot ${timestamp}`;
      case 'drop':
        return `Drag & Drop ${timestamp}`;
      default:
        return `Session ${timestamp}`;
    }
  }, []);

  const handleNewImage = useCallback((details: { path: string; previewUrl: string; source: SessionSource; }) => {
    const sessionId = generateSessionId();
    const timestamp = Date.now();
    const newSession: AppSession = {
      id: sessionId,
      title: deriveSessionTitle(details.path, details.source),
      createdAt: timestamp,
      updatedAt: timestamp,
      source: details.source,
      ocr: {
        imagePath: details.path,
        imagePreviewUrl: details.previewUrl,
        processedImageUrl: '',
        ocrText: '',
        optimizedText: '',
        textDisplayMode: 'original',
        params
      },
      prompt: {
        imageStyle,
        customDescription,
        optimizedPrompt: ''
      },
      generation: {
        aspectRatio,
        generatedImageUrl: '',
        generatedImageRemoteUrl: ''
      }
    };

    setSessions(prev => [newSession, ...prev].sort((a, b) => b[sortBy] - a[sortBy]));
    setActiveSessionId(sessionId);
    setHasPerformedOcr(false);

    // Track the mapping from image path to session ID
    imagePathToSessionIdRef.current.set(details.path, sessionId);

    lastAutoOptimizedOcrRef.current = '';
    lastAutoPromptRef.current = '';
    lastAutoGeneratedImageRef.current = '';
    lastAutoSavedImageRef.current = '';

    // Return the session ID so caller can update the session later
    return sessionId;
  }, [aspectRatio, customDescription, deriveSessionTitle, generateSessionId, imageStyle, params]);

  useEffect(() => {
    onNewImageHandlerRef.current = handleNewImage;
  }, [handleNewImage]);

  // Re-sort sessions when sortBy changes
  useEffect(() => {
    setSessions(prev => {
      return [...prev].sort((a, b) => b[sortBy] - a[sortBy]);
    });
  }, [sortBy]);

  // Note: Auto-optimization is handled in handleOcrComplete for all sessions
  // This useEffect is removed to prevent duplicate optimization calls
  // useEffect(() => {
  //   if (isAutomationLoading) {
  //     return;
  //   }
  //
  //   if (!automationSettings.autoOptimizeOcr || !ocrText.trim() || isRestoringSessionRef.current || isOptimizingText) {
  //     return;
  //   }
  //
  //   if (lastAutoOptimizedOcrRef.current === ocrText) {
  //     return;
  //   }
  //
  //   lastAutoOptimizedOcrRef.current = ocrText;
  //   void optimizeOcrText();
  // }, [automationSettings.autoOptimizeOcr, isAutomationLoading, isOptimizingText, ocrText, optimizeOcrText]);

  // Update the active session's OCR state
  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update session state while optimization is in progress
    // This prevents saving incomplete/incorrect optimization results
    if (isOptimizingText) {
      return;
    }

    setSessions(prev => {
      let didUpdate = false;
      const next = prev.map(session => {
        if (session.id !== activeSessionId) {
          return session;
        }
        didUpdate = true;
        return {
          ...session,
          updatedAt: Date.now(),
          ocr: {
            imagePath,
            imagePreviewUrl,
            processedImageUrl,
            ocrText,
            optimizedText,
            textDisplayMode,
            params
          }
        };
      });

      if (!didUpdate) {
        return prev;
      }

      return [...next].sort((a, b) => b[sortBy] - a[sortBy]);
    });
  }, [activeSessionId, imagePath, imagePreviewUrl, processedImageUrl, ocrText, optimizedText, textDisplayMode, params, isRestoringSessionRef, isOptimizingText, isSessionsLoading]);

  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update while optimization is in progress
    if (isOptimizing) {
      return;
    }

    setSessions(prev => {
      let didUpdate = false;
      const next = prev.map(session => {
        if (session.id !== activeSessionId) {
          return session;
        }
        didUpdate = true;
        return {
          ...session,
          updatedAt: Date.now(),
          prompt: {
            imageStyle,
            customDescription,
            optimizedPrompt
          }
        };
      });

      if (!didUpdate) {
        return prev;
      }

      return [...next].sort((a, b) => b[sortBy] - a[sortBy]);
    });
  }, [activeSessionId, imageStyle, customDescription, optimizedPrompt, isRestoringSessionRef, isOptimizing, isSessionsLoading]);

  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update while generation is in progress
    if (isGenerating) {
      return;
    }

    setSessions(prev => {
      let didUpdate = false;
      const next = prev.map(session => {
        if (session.id !== activeSessionId) {
          return session;
        }
        didUpdate = true;
        return {
          ...session,
          updatedAt: Date.now(),
          generation: {
            aspectRatio,
            // Don't save the temporary blob URL, only save the remote URL
            // The blob URL will be recreated when loading the session
            generatedImageUrl: '',
            generatedImageRemoteUrl
          }
        };
      });

      if (!didUpdate) {
        return prev;
      }

      return [...next].sort((a, b) => b[sortBy] - a[sortBy]);
    });
  }, [activeSessionId, aspectRatio, generatedImageRemoteUrl, isRestoringSessionRef, isGenerating, isSessionsLoading]);

  // Track OCR state changes
  const previousOcrText = useRef<string>('');
  useEffect(() => {
    // Don't reset prompt when restoring a session
    if (isRestoringSessionRef.current) {
      return;
    }

    if (previousOcrText.current !== ocrText) {
      // OCR text changed - mark as performed if not empty
      if (ocrText) {
        setHasPerformedOcr(true);
      }

      // Reset prompt when OCR text changes, but keep the generated image
      // Users may want to keep the generated image even if OCR text changes
      if (previousOcrText.current) {
        setOptimizedPrompt('');
        // Don't reset generation state - let users manually clear if needed
      }

      previousOcrText.current = ocrText;
    }
  }, [ocrText, setOptimizedPrompt]);

  const handleGenerateImage = useCallback(() => {
    if (!optimizedPrompt.trim()) {
      return;
    }
    lastAutoGeneratedImageRef.current = optimizedPrompt;
    void generateImage(optimizedPrompt);
  }, [generateImage, optimizedPrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGeneratePrompt || !ocrText.trim() || isRestoringSessionRef.current || isOptimizing) {
      return;
    }

    if (lastAutoPromptRef.current === ocrText) {
      return;
    }

    lastAutoPromptRef.current = ocrText;
    void optimizePrompt();
  }, [automationSettings.autoGeneratePrompt, isAutomationLoading, isOptimizing, ocrText, optimizePrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGenerateImage || !optimizedPrompt.trim() || isRestoringSessionRef.current || isGenerating) {
      return;
    }

    if (lastAutoGeneratedImageRef.current === optimizedPrompt) {
      return;
    }

    lastAutoGeneratedImageRef.current = optimizedPrompt;
    void generateImage(optimizedPrompt);
  }, [automationSettings.autoGenerateImage, generateImage, isAutomationLoading, isGenerating, optimizedPrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoSaveImage ||
        !automationSettings.autoSaveDirectory.trim() ||
        !generatedImageUrl ||
        isRestoringSessionRef.current) {
      return;
    }

    if (lastAutoSavedImageRef.current === generatedImageUrl) {
      return;
    }

    lastAutoSavedImageRef.current = generatedImageUrl;
    void saveGeneratedImageToDirectory(automationSettings.autoSaveDirectory).catch(() => {
      // Error already surfaced via generation status; no-op here.
    });
  }, [
    automationSettings.autoSaveDirectory,
    automationSettings.autoSaveImage,
    generatedImageUrl,
    isAutomationLoading,
    saveGeneratedImageToDirectory
  ]);

  const handleCopyPrompt = () => {
    if (!optimizedPrompt.trim()) {
      return;
    }

    navigator.clipboard.writeText(optimizedPrompt).catch(error => {
      console.error('Failed to copy optimized prompt:', error);
    });
  };

  const handleSelectAutoSaveDirectory = useCallback(async () => {
    try {
      const selected = await openDialog({
        directory: true,
        multiple: false,
        defaultPath: automationSettings.autoSaveDirectory || undefined
      });

      if (typeof selected === 'string' && selected.trim()) {
        updateAutomationSetting('autoSaveDirectory', selected);
      }
    } catch (error) {
      console.error('Failed to select auto-save directory:', error);
    }
  }, [automationSettings.autoSaveDirectory, updateAutomationSetting]);

  const handleLanguageChange = (language: string) => {
    updateParam('language', language);
  };

  const toggleAdvanced = () => setShowAdvanced(prev => !prev);

  const shouldShowGeneratedPanel = isGenerating || Boolean(generatedImageUrl);
  const gridClassName = `main-content-three-column${shouldShowGeneratedPanel ? ' has-generated' : ''}`;

  useKeyboardShortcuts({
    onSelectImage: () => { void selectImage(); },
    onTakeScreenshot: () => { void takeScreenshot(); },
    onPerformOcr: () => { void performOCR(); },
    onCopyText: () => { void copyOcrText(); },
    onSaveText: () => { void saveOcrText(); },
    onToggleAdvanced: toggleAdvanced,
    onOpenSettings: () => setIsSettingsOpen(true),
    canPerformOcr: Boolean(imagePath),
    hasOcrText: Boolean(ocrText.trim())
  });

  const handleSelectSession = useCallback((sessionId: string) => {
    if (sessionId === activeSessionId) {
      setIsSidebarOpen(false);
      return;
    }

    const session = sessions.find(item => item.id === sessionId);
    if (!session) {
      return;
    }

    // Prevent switching while already restoring
    if (isRestoringSessionRef.current) {
      console.log('Session restore already in progress, ignoring click');
      return;
    }

    const restoreSession = async () => {
      isRestoringSessionRef.current = true;
      suppressAutoProcessRef.current = true;
      suppressPromptResetRef.current = true;

      try {
        // First set the active session ID before loading snapshots
        // This ensures the effects know which session is being restored
        setActiveSessionId(sessionId);

        // Then load all the snapshots
        loadOcrSnapshot(session.ocr);
        loadPromptSnapshot(session.prompt);
        await loadGenerationSnapshot(session.generation);

        // Check if session has any OCR data (text or processed image)
        const hasOcrData = Boolean(session.ocr.ocrText || session.ocr.processedImageUrl);
        setHasPerformedOcr(hasOcrData);

        setSessions(prev => {
          const next = prev.map(item => item.id === sessionId
            ? { ...item, updatedAt: Date.now() }
            : item);
          return [...next].sort((a, b) => b[sortBy] - a[sortBy]);
        });
      } finally {
        // Use setTimeout instead of requestAnimationFrame for more reliable timing
        // Increase delay to ensure all state updates complete
        setTimeout(() => {
          suppressAutoProcessRef.current = false;
          suppressPromptResetRef.current = false;
          isRestoringSessionRef.current = false;
        }, 300);
      }
    };

    void restoreSession();
    setIsSidebarOpen(false);
  }, [
    activeSessionId,
    sessions,
    loadOcrSnapshot,
    loadPromptSnapshot,
    loadGenerationSnapshot,
    suppressAutoProcessRef,
    suppressPromptResetRef
  ]);

  const handleDeleteSession = useCallback((sessionId: string) => {
    setSessions(prev => prev.filter(session => session.id !== sessionId));

    // If we deleted the active session, clear the active session
    if (sessionId === activeSessionId) {
      setActiveSessionId(null);
      setHasPerformedOcr(false);
    }
  }, [activeSessionId]);

  return (
    <div
      className="container"
      {...dragAndDropHandlers}
    >
      <h1>Imagio</h1>

      <div className="shortcuts-hint">
        ⌨️ Shortcuts: <kbd>⌘O</kbd> Open | <kbd>⌘⇧S</kbd> Screenshot | <kbd>⌘C</kbd> Copy | <kbd>⌘S</kbd> Save | <kbd>⌘,</kbd> Settings
      </div>

      <DropOverlay isVisible={isDragging} />

      <OverlaySidebar
        isOpen={isSidebarOpen}
        onClose={() => setIsSidebarOpen(false)}
        automationSettings={automationSettings}
        onAutomationSettingChange={updateAutomationSetting}
        onSelectAutoSaveDirectory={() => { void handleSelectAutoSaveDirectory(); }}
        sessions={sessions}
        activeSessionId={activeSessionId}
        onSelectSession={handleSelectSession}
        onDeleteSession={handleDeleteSession}
        onOpenSettings={() => {
          setIsSidebarOpen(false);
          setIsSettingsOpen(true);
        }}
        sortBy={sortBy}
        onSortByChange={setSortBy}
      />

      <SettingsModal
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        llmSettings={llmSettings}
        onLLMSettingChange={updateLLMSetting}
        bflApiKey={bflApiKey}
        onBflApiKeyChange={setBflApiKey}
      />

      <Toolbar
        onSelectImage={() => { void selectImage(); }}
        onTakeScreenshot={() => { void takeScreenshot(); }}
        language={params.language}
        onLanguageChange={handleLanguageChange}
        showAdvanced={showAdvanced}
        onToggleAdvanced={toggleAdvanced}
        onToggleSidebar={() => setIsSidebarOpen(true)}
      />

      {showAdvanced && (
        <AdvancedControls
          params={params}
          onParamChange={updateParam}
        />
      )}

      <ProcessingStatus isProcessing={isProcessing} statusMessage={processingStatus} />

      {imagePath && (
        <div className={gridClassName}>
          <div className="left-panel">
            <OcrPreviewPanel
              imagePreviewUrl={imagePreviewUrl}
              processedImageUrl={processedImageUrl}
            />
          </div>

          <div className="middle-panel">
            {hasPerformedOcr && (
              <OcrTextPanel
                value={ocrText}
                onChange={updateOcrText}
                onCopy={() => copyOcrText()}
                onSave={() => saveOcrText()}
                optimizedText={optimizedText}
                isOptimizing={isOptimizingText}
                onOptimize={optimizeOcrText}
                textDisplayMode={textDisplayMode}
                onTextDisplayModeChange={setTextDisplayMode}
                onOptimizedTextChange={updateOptimizedText}
              />
            )}
          </div>

          {hasPerformedOcr && (
            <>
              <div className="right-panel">
                <PromptGenerationPanel
                  imageStyle={imageStyle}
                  onImageStyleChange={setImageStyle}
                  aspectRatio={aspectRatio}
                  onAspectRatioChange={setAspectRatio}
                  customDescription={customDescription}
                  onCustomDescriptionChange={setCustomDescription}
                  optimizedPrompt={optimizedPrompt}
                  onOptimizedPromptChange={setOptimizedPrompt}
                  onOptimize={optimizePrompt}
                  isOptimizing={isOptimizing}
                  llmError={llmError}
                  isOptimizeDisabled={!ocrText.trim()}
                  onCopyPrompt={handleCopyPrompt}
                  onGenerateImage={handleGenerateImage}
                  isGenerating={isGenerating}
                />
              </div>

              {shouldShowGeneratedPanel && (
                <div className="generated-panel">
                  <GeneratedImagePanel
                    generatedImageUrl={generatedImageUrl}
                    isGenerating={isGenerating}
                    generationStatus={generationStatus}
                    onSaveGeneratedImage={() => saveGeneratedImage()}
                    onCopyGeneratedImage={() => copyGeneratedImageToClipboard()}
                    onCopyGeneratedImageUrl={() => copyGeneratedImageUrl()}
                    onClearGeneratedImage={clearGeneratedImage}
                    hasRemoteImageUrl={Boolean(generatedImageRemoteUrl)}
                  />
                </div>
              )}
            </>
          )}
        </div>
      )}
    </div>
  );
};

export default App;
