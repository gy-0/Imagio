import { useCallback, useEffect, useRef, useState } from 'react';
import { DropOverlay } from './components/DropOverlay';
import { ProcessingStatus } from './components/ProcessingStatus';
import { Toolbar } from './components/toolbar/Toolbar';
import { OverlaySidebar } from './components/OverlaySidebar';
import { SettingsModal } from './components/SettingsModal';
import { useApplicationConfig } from './hooks/useApplicationConfig';
import { useAutomationSettings } from './hooks/useAutomationSettings';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { AdvancedControls } from './features/ocr/components/AdvancedControls';
import { OcrPreviewPanel } from './features/ocr/components/OcrPreviewPanel';
import { OcrTextPanel } from './features/ocr/components/OcrTextPanel';
import { useOcrProcessing } from './features/ocr/useOcrProcessing';
import { useImageGeneration } from './features/imageGeneration/useImageGeneration';
import { PromptGenerationPanel } from './features/promptOptimization/components/PromptGenerationPanel';
import { GeneratedImagePanel } from './features/promptOptimization/components/GeneratedImagePanel';
import { usePromptOptimization } from './features/promptOptimization/usePromptOptimization';
import type { AppSession, SessionSource } from './types/appSession';
import { open as openDialog } from '@tauri-apps/plugin-dialog';
import './App.css';

const App = () => {
  const [showAdvanced, setShowAdvanced] = useState<boolean>(false);
  const [hasPerformedOcr, setHasPerformedOcr] = useState<boolean>(false);
  const [isSidebarOpen, setIsSidebarOpen] = useState<boolean>(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState<boolean>(false);
  const [sessions, setSessions] = useState<AppSession[]>([]);
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const suppressAutoProcessRef = useRef<boolean>(false);
  const suppressPromptResetRef = useRef<boolean>(false);
  const isRestoringSessionRef = useRef<boolean>(false);
  const lastAutoOptimizedOcrRef = useRef<string>('');
  const lastAutoPromptRef = useRef<string>('');
  const lastAutoGeneratedImageRef = useRef<string>('');
  const lastAutoSavedImageRef = useRef<string>('');
  const onNewImageHandlerRef = useRef<((details: { path: string; previewUrl: string; source: 'file' | 'drop' | 'screenshot'; }) => string) | null>(null);
  const imagePathToSessionIdRef = useRef<Map<string, string>>(new Map());

  const {
    llmSettings,
    updateLLMSetting,
    bflApiKey,
    setBflApiKey
  } = useApplicationConfig();
  const {
    settings: automationSettings,
    updateSetting: updateAutomationSetting,
    isLoading: isAutomationLoading
  } = useAutomationSettings();

  const {
    aspectRatio,
    setAspectRatio,
    generatedImageUrl,
    generatedImageRemoteUrl,
    isGenerating,
    generationStatus,
    generateImage,
    saveGeneratedImage,
    copyGeneratedImageUrl,
    copyGeneratedImageToClipboard,
    clearGeneratedImage,
    resetGenerationState,
    saveGeneratedImageToDirectory,
    loadSessionSnapshot: loadGenerationSnapshot
  } = useImageGeneration({ bflApiKey });

  const handleOcrComplete = useCallback((details: { imagePath: string; ocrText: string; processedImageUrl: string; }) => {
    // Find the session ID for this image path
    const sessionId = imagePathToSessionIdRef.current.get(details.imagePath);
    if (!sessionId) {
      console.warn('No session found for image path:', details.imagePath);
      return;
    }

    // Update the session directly with OCR results
    setSessions(prev => {
      const next = prev.map(session => {
        if (session.id !== sessionId) {
          return session;
        }
        return {
          ...session,
          updatedAt: Date.now(),
          ocr: {
            ...session.ocr,
            processedImageUrl: details.processedImageUrl,
            ocrText: details.ocrText
          }
        };
      });
      return [...next].sort((a, b) => b.updatedAt - a.updatedAt);
    });

    // Clean up the mapping
    imagePathToSessionIdRef.current.delete(details.imagePath);
  }, []);

  const handleOptimizeComplete = useCallback((details: { imagePath: string; optimizedText: string; }) => {
    // Find the session for this image path
    setSessions(prev => {
      const next = prev.map(session => {
        if (session.ocr.imagePath !== details.imagePath) {
          return session;
        }
        return {
          ...session,
          updatedAt: Date.now(),
          ocr: {
            ...session.ocr,
            optimizedText: details.optimizedText,
            textDisplayMode: 'optimized' as const
          }
        };
      });
      return [...next].sort((a, b) => b.updatedAt - a.updatedAt);
    });
  }, []);

  const {
    imagePath,
    imagePreviewUrl,
    processedImageUrl,
    ocrText,
    updateOcrText,
    optimizedText,
    updateOptimizedText,
    isOptimizingText,
    textDisplayMode,
    setTextDisplayMode,
    optimizeOcrText,
    isProcessing,
    processingStatus,
    params,
    updateParam,
    selectImage,
    takeScreenshot,
    performOCR,
    copyOcrText,
    saveOcrText,
    isDragging,
    dragAndDropHandlers,
    loadSessionSnapshot: loadOcrSnapshot
  } = useOcrProcessing({
    llmSettings,
    suppressAutoProcessRef,
    onNewImage: (details) => {
      return onNewImageHandlerRef.current?.(details) ?? '';
    },
    onOcrComplete: handleOcrComplete,
    onOptimizeComplete: handleOptimizeComplete
  });

  const {
    imageStyle,
    customDescription,
    optimizedPrompt,
    isOptimizing,
    llmError,
    setImageStyle,
    setCustomDescription,
    setOptimizedPrompt,
    optimizePrompt,
    loadSessionSnapshot: loadPromptSnapshot
  } = usePromptOptimization(llmSettings, ocrText, {
    suppressOcrResetRef: suppressPromptResetRef
  });

  const generateSessionId = useCallback(() => {
    if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
      return crypto.randomUUID();
    }
    return `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }, []);

  const deriveSessionTitle = useCallback((path: string, source: SessionSource) => {
    if (path) {
      const parts = path.split(/[/\\]/);
      const filename = parts[parts.length - 1];
      if (filename) {
        return filename;
      }
    }

    const timestamp = new Date().toLocaleTimeString();
    switch (source) {
      case 'screenshot':
        return `Screenshot ${timestamp}`;
      case 'drop':
        return `Drag & Drop ${timestamp}`;
      default:
        return `Session ${timestamp}`;
    }
  }, []);

  const handleNewImage = useCallback((details: { path: string; previewUrl: string; source: SessionSource; }) => {
    const sessionId = generateSessionId();
    const timestamp = Date.now();
    const newSession: AppSession = {
      id: sessionId,
      title: deriveSessionTitle(details.path, details.source),
      createdAt: timestamp,
      updatedAt: timestamp,
      source: details.source,
      ocr: {
        imagePath: details.path,
        imagePreviewUrl: details.previewUrl,
        processedImageUrl: '',
        ocrText: '',
        optimizedText: '',
        textDisplayMode: 'original'
      },
      prompt: {
        imageStyle,
        customDescription,
        optimizedPrompt: ''
      },
      generation: {
        aspectRatio,
        generatedImageUrl: '',
        generatedImageRemoteUrl: ''
      }
    };

    setSessions(prev => [newSession, ...prev]);
    setActiveSessionId(sessionId);

    // Track the mapping from image path to session ID
    imagePathToSessionIdRef.current.set(details.path, sessionId);

    lastAutoOptimizedOcrRef.current = '';
    lastAutoPromptRef.current = '';
    lastAutoGeneratedImageRef.current = '';
    lastAutoSavedImageRef.current = '';

    // Return the session ID so caller can update the session later
    return sessionId;
  }, [aspectRatio, customDescription, deriveSessionTitle, generateSessionId, imageStyle]);

  useEffect(() => {
    onNewImageHandlerRef.current = handleNewImage;
  }, [handleNewImage]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoOptimizeOcr || !ocrText.trim() || isRestoringSessionRef.current || isOptimizingText) {
      return;
    }

    if (lastAutoOptimizedOcrRef.current === ocrText) {
      return;
    }

    lastAutoOptimizedOcrRef.current = ocrText;
    void optimizeOcrText();
  }, [automationSettings.autoOptimizeOcr, isAutomationLoading, isOptimizingText, ocrText, optimizeOcrText]);

  // Update the active session's OCR state
  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current) {
      return;
    }

    // Don't update session state while optimization is in progress
    // This prevents saving incomplete/incorrect optimization results
    if (isOptimizingText) {
      return;
    }

    setSessions(prev => {
      let didUpdate = false;
      const next = prev.map(session => {
        if (session.id !== activeSessionId) {
          return session;
        }
        didUpdate = true;
        return {
          ...session,
          updatedAt: Date.now(),
          ocr: {
            imagePath,
            imagePreviewUrl,
            processedImageUrl,
            ocrText,
            optimizedText,
            textDisplayMode
          }
        };
      });

      if (!didUpdate) {
        return prev;
      }

      return [...next].sort((a, b) => b.updatedAt - a.updatedAt);
    });
  }, [activeSessionId, imagePath, imagePreviewUrl, processedImageUrl, ocrText, optimizedText, textDisplayMode, isRestoringSessionRef, isOptimizingText]);

  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current) {
      return;
    }

    setSessions(prev => {
      let didUpdate = false;
      const next = prev.map(session => {
        if (session.id !== activeSessionId) {
          return session;
        }
        didUpdate = true;
        return {
          ...session,
          updatedAt: Date.now(),
          prompt: {
            imageStyle,
            customDescription,
            optimizedPrompt
          }
        };
      });

      if (!didUpdate) {
        return prev;
      }

      return [...next].sort((a, b) => b.updatedAt - a.updatedAt);
    });
  }, [activeSessionId, imageStyle, customDescription, optimizedPrompt, isRestoringSessionRef]);

  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current) {
      return;
    }

    setSessions(prev => {
      let didUpdate = false;
      const next = prev.map(session => {
        if (session.id !== activeSessionId) {
          return session;
        }
        didUpdate = true;
        return {
          ...session,
          updatedAt: Date.now(),
          generation: {
            aspectRatio,
            generatedImageUrl,
            generatedImageRemoteUrl
          }
        };
      });

      if (!didUpdate) {
        return prev;
      }

      return [...next].sort((a, b) => b.updatedAt - a.updatedAt);
    });
  }, [activeSessionId, aspectRatio, generatedImageUrl, generatedImageRemoteUrl, isRestoringSessionRef]);

  // Track OCR state changes
  const previousOcrText = useRef<string>('');
  useEffect(() => {
    if (previousOcrText.current !== ocrText) {
      // OCR text changed - mark as performed if not empty
      if (ocrText) {
        setHasPerformedOcr(true);
      }
      
      // Reset dependent states when OCR text changes
      if (previousOcrText.current) {
        setOptimizedPrompt('');
        resetGenerationState();
      }
      
      previousOcrText.current = ocrText;
    }
  }, [ocrText, resetGenerationState, setOptimizedPrompt]);
  
  // Reset hasPerformedOcr when new image is selected (imagePath changes)
  const previousImagePath = useRef<string>('');
  useEffect(() => {
    if (previousImagePath.current !== imagePath) {
      if (imagePath !== previousImagePath.current && previousImagePath.current !== '') {
        setHasPerformedOcr(false);
      }
      previousImagePath.current = imagePath;
    }
  }, [imagePath]);

  const handleGenerateImage = useCallback(() => {
    if (!optimizedPrompt.trim()) {
      return;
    }
    lastAutoGeneratedImageRef.current = optimizedPrompt;
    void generateImage(optimizedPrompt);
  }, [generateImage, optimizedPrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGeneratePrompt || !ocrText.trim() || isRestoringSessionRef.current || isOptimizing) {
      return;
    }

    if (lastAutoPromptRef.current === ocrText) {
      return;
    }

    lastAutoPromptRef.current = ocrText;
    void optimizePrompt();
  }, [automationSettings.autoGeneratePrompt, isAutomationLoading, isOptimizing, ocrText, optimizePrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGenerateImage || !optimizedPrompt.trim() || isRestoringSessionRef.current || isGenerating) {
      return;
    }

    if (lastAutoGeneratedImageRef.current === optimizedPrompt) {
      return;
    }

    lastAutoGeneratedImageRef.current = optimizedPrompt;
    void generateImage(optimizedPrompt);
  }, [automationSettings.autoGenerateImage, generateImage, isAutomationLoading, isGenerating, optimizedPrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoSaveImage ||
        !automationSettings.autoSaveDirectory.trim() ||
        !generatedImageUrl ||
        isRestoringSessionRef.current) {
      return;
    }

    if (lastAutoSavedImageRef.current === generatedImageUrl) {
      return;
    }

    lastAutoSavedImageRef.current = generatedImageUrl;
    void saveGeneratedImageToDirectory(automationSettings.autoSaveDirectory).catch(() => {
      // Error already surfaced via generation status; no-op here.
    });
  }, [
    automationSettings.autoSaveDirectory,
    automationSettings.autoSaveImage,
    generatedImageUrl,
    isAutomationLoading,
    saveGeneratedImageToDirectory
  ]);

  const handleCopyPrompt = () => {
    if (!optimizedPrompt.trim()) {
      return;
    }

    navigator.clipboard.writeText(optimizedPrompt).catch(error => {
      console.error('Failed to copy optimized prompt:', error);
    });
  };

  const handleSelectAutoSaveDirectory = useCallback(async () => {
    try {
      const selected = await openDialog({
        directory: true,
        multiple: false,
        defaultPath: automationSettings.autoSaveDirectory || undefined
      });

      if (typeof selected === 'string' && selected.trim()) {
        updateAutomationSetting('autoSaveDirectory', selected);
      }
    } catch (error) {
      console.error('Failed to select auto-save directory:', error);
    }
  }, [automationSettings.autoSaveDirectory, updateAutomationSetting]);

  const handleLanguageChange = (language: string) => {
    updateParam('language', language);
  };

  const toggleAdvanced = () => setShowAdvanced(prev => !prev);

  const shouldShowGeneratedPanel = isGenerating || Boolean(generatedImageUrl);
  const gridClassName = `main-content-three-column${shouldShowGeneratedPanel ? ' has-generated' : ''}`;

  useKeyboardShortcuts({
    onSelectImage: () => { void selectImage(); },
    onTakeScreenshot: () => { void takeScreenshot(); },
    onPerformOcr: () => { void performOCR(); },
    onCopyText: () => { void copyOcrText(); },
    onSaveText: () => { void saveOcrText(); },
    onToggleAdvanced: toggleAdvanced,
    canPerformOcr: Boolean(imagePath),
    hasOcrText: Boolean(ocrText.trim())
  });

  const handleSelectSession = useCallback((sessionId: string) => {
    if (sessionId === activeSessionId) {
      setIsSidebarOpen(false);
      return;
    }

    const session = sessions.find(item => item.id === sessionId);
    if (!session) {
      return;
    }

    // Prevent switching while already restoring
    if (isRestoringSessionRef.current) {
      console.log('Session restore already in progress, ignoring click');
      return;
    }

    const restoreSession = async () => {
      isRestoringSessionRef.current = true;
      suppressAutoProcessRef.current = true;
      suppressPromptResetRef.current = true;

      try {
        loadOcrSnapshot(session.ocr);
        loadPromptSnapshot(session.prompt);
        await loadGenerationSnapshot(session.generation);

        setActiveSessionId(sessionId);
        // Check if session has any OCR data (text or processed image)
        const hasOcrData = Boolean(session.ocr.ocrText || session.ocr.processedImageUrl);
        setHasPerformedOcr(hasOcrData);

        setSessions(prev => {
          const next = prev.map(item => item.id === sessionId
            ? { ...item, updatedAt: Date.now() }
            : item);
          return [...next].sort((a, b) => b.updatedAt - a.updatedAt);
        });
      } finally {
        // Use setTimeout instead of requestAnimationFrame for more reliable timing
        setTimeout(() => {
          suppressAutoProcessRef.current = false;
          suppressPromptResetRef.current = false;
          isRestoringSessionRef.current = false;
        }, 100);
      }
    };

    void restoreSession();
    setIsSidebarOpen(false);
  }, [
    activeSessionId,
    sessions,
    loadOcrSnapshot,
    loadPromptSnapshot,
    loadGenerationSnapshot,
    suppressAutoProcessRef,
    suppressPromptResetRef
  ]);

  return (
    <div
      className="container"
      {...dragAndDropHandlers}
    >
      <h1>Imagio - OCR Application</h1>

      <div className="shortcuts-hint">
        ⌨️ Shortcuts: <kbd>⌘O</kbd> Open | <kbd>⌘⇧S</kbd> Screenshot | <kbd>⌘C</kbd> Copy | <kbd>⌘S</kbd> Save
      </div>

      <DropOverlay isVisible={isDragging} />

      <OverlaySidebar
        isOpen={isSidebarOpen}
        onClose={() => setIsSidebarOpen(false)}
        automationSettings={automationSettings}
        onAutomationSettingChange={updateAutomationSetting}
        onSelectAutoSaveDirectory={() => { void handleSelectAutoSaveDirectory(); }}
        sessions={sessions}
        activeSessionId={activeSessionId}
        onSelectSession={handleSelectSession}
        onOpenSettings={() => {
          setIsSidebarOpen(false);
          setIsSettingsOpen(true);
        }}
      />

      <SettingsModal
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        llmSettings={llmSettings}
        onLLMSettingChange={updateLLMSetting}
        bflApiKey={bflApiKey}
        onBflApiKeyChange={setBflApiKey}
      />

      <Toolbar
        onSelectImage={() => { void selectImage(); }}
        onTakeScreenshot={() => { void takeScreenshot(); }}
        language={params.language}
        onLanguageChange={handleLanguageChange}
        showAdvanced={showAdvanced}
        onToggleAdvanced={toggleAdvanced}
        onToggleSidebar={() => setIsSidebarOpen(true)}
      />

      {showAdvanced && (
        <AdvancedControls
          params={params}
          onParamChange={updateParam}
        />
      )}

      <ProcessingStatus isProcessing={isProcessing} statusMessage={processingStatus} />

      {imagePath && (
        <div className={gridClassName}>
          <div className="left-panel">
            <OcrPreviewPanel
              imagePreviewUrl={imagePreviewUrl}
              processedImageUrl={processedImageUrl}
            />
          </div>

          <div className="middle-panel">
            {hasPerformedOcr && (
              <OcrTextPanel
                value={ocrText}
                onChange={updateOcrText}
                onCopy={() => copyOcrText()}
                onSave={() => saveOcrText()}
                optimizedText={optimizedText}
                isOptimizing={isOptimizingText}
                onOptimize={optimizeOcrText}
                textDisplayMode={textDisplayMode}
                onTextDisplayModeChange={setTextDisplayMode}
                onOptimizedTextChange={updateOptimizedText}
              />
            )}
          </div>

          {hasPerformedOcr && (
            <>
              <div className="right-panel">
                <PromptGenerationPanel
                  imageStyle={imageStyle}
                  onImageStyleChange={setImageStyle}
                  aspectRatio={aspectRatio}
                  onAspectRatioChange={setAspectRatio}
                  customDescription={customDescription}
                  onCustomDescriptionChange={setCustomDescription}
                  optimizedPrompt={optimizedPrompt}
                  onOptimizedPromptChange={setOptimizedPrompt}
                  onOptimize={optimizePrompt}
                  isOptimizing={isOptimizing}
                  llmError={llmError}
                  isOptimizeDisabled={!ocrText.trim()}
                  onCopyPrompt={handleCopyPrompt}
                  onGenerateImage={handleGenerateImage}
                  isGenerating={isGenerating}
                />
              </div>

              {shouldShowGeneratedPanel && (
                <div className="generated-panel">
                  <GeneratedImagePanel
                    generatedImageUrl={generatedImageUrl}
                    isGenerating={isGenerating}
                    generationStatus={generationStatus}
                    onSaveGeneratedImage={() => saveGeneratedImage()}
                    onCopyGeneratedImage={() => copyGeneratedImageToClipboard()}
                    onCopyGeneratedImageUrl={() => copyGeneratedImageUrl()}
                    onClearGeneratedImage={clearGeneratedImage}
                    hasRemoteImageUrl={Boolean(generatedImageRemoteUrl)}
                  />
                </div>
              )}
            </>
          )}
        </div>
      )}
    </div>
  );
};

export default App;
