import { useCallback, useEffect, useRef, useState } from 'react';
import { ProcessingStatus } from './components/ProcessingStatus';
import { Toolbar } from './components/toolbar/Toolbar';
import { SidebarContainer } from './features/sidebar/containers/SidebarContainer';
import { SettingsContainer } from './features/settings/containers/SettingsContainer';
import { EmptyState } from './components/EmptyState';
import { ErrorBoundary } from './components/ErrorBoundary';
import { ErrorNotification } from './components/ErrorNotification';
import { useErrorHandler } from './hooks/useErrorHandler';
import { useApplicationConfig } from './hooks/useApplicationConfig';
import { useAutomationSettings } from './hooks/useAutomationSettings';
import { useSessionManager } from './hooks/useSessionManager';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { OcrPreviewPanel } from './features/ocr/components/OcrPreviewPanel';
import { OcrTextPanel } from './features/ocr/components/OcrTextPanel';
import { useOcrProcessing } from './features/ocr/useOcrProcessing';
import { useImageGeneration } from './features/imageGeneration/useImageGeneration';
import { PromptGenerationPanel } from './features/promptOptimization/components/PromptGenerationPanel';
import { GeneratedImagePanel } from './features/promptOptimization/components/GeneratedImagePanel';
import { usePromptOptimization } from './features/promptOptimization/usePromptOptimization';
import { updateSessionInPlace } from './utils/sessionUtils';
import { MAIN_GRID_CLASS } from './constants';
import './App.css';

const App = () => {
  const [hasPerformedOcr, setHasPerformedOcr] = useState<boolean>(false);
  const [isSidebarOpen, setIsSidebarOpen] = useState<boolean>(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState<boolean>(false);
  const [currentGenerationSessionId, setCurrentGenerationSessionId] = useState<string | null>(null);
  const [generatedImageOwnerSessionId, setGeneratedImageOwnerSessionId] = useState<string | null>(null);
  const suppressAutoProcessRef = useRef<boolean>(false);
  const suppressPromptResetRef = useRef<boolean>(false);
  const lastAutoOptimizedOcrRef = useRef<string>('');
  const lastAutoPromptRef = useRef<string>('');
  const lastAutoGeneratedImageRef = useRef<string>('');
  const lastAutoSavedImageRef = useRef<string>('');
  const optimizeOcrTextRef = useRef<((textToOptimize?: string) => Promise<void>) | null>(null);
  const currentGenerationSessionIdRef = useRef<string | null>(null);
  // automationSettingsRef will be initialized after automationSettings is declared

  const {
    llmSettings,
    updateLLMSetting,
    bflApiKey,
    setBflApiKey,
    geminiApiKey,
    setGeminiApiKey,
    bltcyApiKey,
    setBltcyApiKey,
    selectedModel,
    setSelectedModel
  } = useApplicationConfig();
  const {
    settings: automationSettings,
    updateSetting: updateAutomationSetting,
    isLoading: isAutomationLoading
  } = useAutomationSettings();
  
  // Initialize automationSettingsRef after automationSettings is declared
  const automationSettingsRef = useRef(automationSettings);

  // Error handling
  const { errors, clearError } = useErrorHandler();

  const {
    aspectRatio,
    setAspectRatio,
    generatedImageUrl,
    generatedImageRemoteUrl,
    generatedImageLocalPath,
    isGenerating,
    generationStatus,
    generateImage,
    saveGeneratedImage,
    copyGeneratedImageUrl,
    copyGeneratedImageToClipboard,
    clearGeneratedImage,
    saveGeneratedImageToDirectory,
    loadSessionSnapshot: loadGenerationSnapshot
  } = useImageGeneration({ bflApiKey, geminiApiKey, bltcyApiKey, selectedModel });

  // Define callback refs that will be initialized after useSessionManager
  const handleOcrCompleteRef = useRef<((details: { imagePath: string; ocrText: string; processedImageUrl: string; }) => void) | null>(null);
  const handleOptimizeCompleteRef = useRef<((details: { imagePath: string; optimizedText: string; }) => void) | null>(null);
  const handleOcrErrorRef = useRef<((details: { imagePath: string; error: string; }) => void) | null>(null);

  const {
    imagePath,
    imagePreviewUrl,
    processedImageUrl,
    ocrText,
    updateOcrText,
    optimizedText,
    updateOptimizedText,
    isOptimizingText,
    textDisplayMode,
    setTextDisplayMode,
    optimizeOcrText,
    isProcessing,
    processingStatus,
    params,
    updateParam,
    selectImage,
    takeScreenshot,
    performOCR,
    copyOcrText,
    saveOcrText,
    loadSessionSnapshot: loadOcrSnapshot
  } = useOcrProcessing({
    llmSettings,
    suppressAutoProcessRef,
    onNewImage: (details) => {
      return onNewImageHandlerRef.current?.(details) ?? '';
    },
    onOcrComplete: (details) => handleOcrCompleteRef.current?.(details),
    onOcrError: (details) => handleOcrErrorRef.current?.(details),
    onOptimizeComplete: (details) => handleOptimizeCompleteRef.current?.(details)
  });

  const {
    imageStyle,
    customDescription,
    optimizedPrompt,
    isOptimizing,
    llmError,
    setImageStyle,
    setCustomDescription,
    setOptimizedPrompt,
    optimizePrompt,
    loadSessionSnapshot: loadPromptSnapshot
  } = usePromptOptimization(llmSettings, ocrText, {
    suppressOcrResetRef: suppressPromptResetRef
  });

  // Session management
  const {
    sessions,
    setSessions,
    activeSessionId,
    sortBy,
    setSortBy,
    isSessionsLoading,
    isRestoringSessionRef,
    activeSessionIdRef,
    onNewImageHandlerRef,
    handleNewImage,
    handleSelectSession: sessionManagerSelectSession,
    handleDeleteSession: sessionManagerDeleteSession,
    updateSession,
    getSessionIdForImagePath,
    removeImagePathMapping
  } = useSessionManager({
    loadOcrSnapshot,
    loadPromptSnapshot,
    loadGenerationSnapshot,
    defaultOcrParams: params,
    defaultPromptState: {
      imageStyle,
      customDescription
    },
    defaultGenerationState: {
      aspectRatio
    }
  });

  // Wrap handleNewImage to add additional state updates
  const wrappedHandleNewImage = useCallback((details: { path: string; previewUrl: string; source: 'file' | 'drop' | 'screenshot'; }) => {
    const sessionId = handleNewImage(details);
    setHasPerformedOcr(false);
    setGeneratedImageOwnerSessionId(sessionId);
    lastAutoOptimizedOcrRef.current = '';
    lastAutoPromptRef.current = '';
    lastAutoGeneratedImageRef.current = '';
    lastAutoSavedImageRef.current = '';
    return sessionId;
  }, [handleNewImage, setGeneratedImageOwnerSessionId]);

  useEffect(() => {
    onNewImageHandlerRef.current = wrappedHandleNewImage;
  }, [wrappedHandleNewImage]);

  // Define OCR callback implementations
  const handleOcrComplete = useCallback((details: { imagePath: string; ocrText: string; processedImageUrl: string; }) => {
    // Find the session ID for this image path
    const sessionId = getSessionIdForImagePath(details.imagePath);
    if (!sessionId) {
      console.warn('No session found for image path:', details.imagePath);
      return;
    }

    // Use ref to get the latest activeSessionId to avoid stale closure values
    const currentActiveSessionId = activeSessionIdRef.current;
    const currentAutomationSettings = automationSettingsRef.current;

    // Update hasPerformedOcr if this is the active session
    if (sessionId === currentActiveSessionId) {
      setHasPerformedOcr(true);
    }

    // Update the session directly with OCR results
    // Keep the params from the session (including language setting)
    setSessions(prev => updateSessionInPlace(prev, sessionId, session => ({
      ...session,
      updatedAt: Date.now(),
      ocr: {
        ...session.ocr,
        processedImageUrl: details.processedImageUrl,
        ocrText: details.ocrText,
        // Clear optimizedText to prevent old content from persisting
        optimizedText: '',
        textDisplayMode: 'original' as const
        // params remains from session.ocr.params - no change needed
      }
    }), sortBy));

    // Auto-optimize: Only trigger for current active session to ensure state is correctly synchronized
    // Use refs to check latest values instead of closure values
    if (sessionId === currentActiveSessionId && currentAutomationSettings.autoOptimizeOcr && details.ocrText.trim() && !isRestoringSessionRef.current) {
      // Mark this text as being optimized to prevent duplicate optimization
      lastAutoOptimizedOcrRef.current = details.ocrText;
      // Pass the OCR text directly to ensure we use the latest value
      // Use the hook's optimizeOcrText function to ensure all state updates are synchronized
      void optimizeOcrTextRef.current?.(details.ocrText);
    }

    // Auto-generate prompt: If this is the current active session and auto-generate prompt is enabled
    // Use refs to check latest values instead of closure values
    if (sessionId === currentActiveSessionId && currentAutomationSettings.autoGeneratePrompt && details.ocrText.trim() && !isRestoringSessionRef.current) {
      // Reset the lastAutoPromptRef to allow auto-generation for the new image
      lastAutoPromptRef.current = '';
    }

    // Clean up the mapping
    removeImagePathMapping(details.imagePath);
  }, [getSessionIdForImagePath, removeImagePathMapping, setSessions, sortBy, activeSessionIdRef, isRestoringSessionRef]);

  const handleOptimizeComplete = useCallback((details: { imagePath: string; optimizedText: string; }) => {
    // Find the session for this image path
    const session = sessions.find(s => s.ocr.imagePath === details.imagePath);
    if (!session) return;

    updateSession(session.id, s => ({
      ...s,
      updatedAt: Date.now(),
      ocr: {
        ...s.ocr,
        optimizedText: details.optimizedText,
        textDisplayMode: 'optimized' as const
      }
    }));
  }, [sessions, updateSession]);

  const handleOcrError = useCallback((details: { imagePath: string; error: string; }) => {
    // Clean up the mapping to prevent memory leak
    removeImagePathMapping(details.imagePath);
    console.error('OCR processing failed:', details.error, 'for image:', details.imagePath);
  }, [removeImagePathMapping]);

  // Assign callbacks to refs
  useEffect(() => {
    handleOcrCompleteRef.current = handleOcrComplete;
  }, [handleOcrComplete]);

  useEffect(() => {
    handleOptimizeCompleteRef.current = handleOptimizeComplete;
  }, [handleOptimizeComplete]);

  useEffect(() => {
    handleOcrErrorRef.current = handleOcrError;
  }, [handleOcrError]);

  useEffect(() => {
    optimizeOcrTextRef.current = optimizeOcrText;
  }, [optimizeOcrText]);

  useEffect(() => {
    automationSettingsRef.current = automationSettings;
  }, [automationSettings]);

  // Auto-optimize when setting is enabled and OCR text exists without optimization
  // This works in conjunction with handleOcrComplete to support two scenarios:
  // 1. Auto-optimize on OCR completion (handled in handleOcrComplete)
  // 2. Auto-optimize when user enables the setting after OCR is complete (handled here)
  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoOptimizeOcr || !ocrText.trim() || isRestoringSessionRef.current || isOptimizingText) {
      return;
    }

    // Only auto-optimize if there's no optimized text yet
    // This prevents duplicate optimization when handleOcrComplete already optimized
    if (optimizedText.trim()) {
      return;
    }

    if (lastAutoOptimizedOcrRef.current === ocrText) {
      return;
    }

    lastAutoOptimizedOcrRef.current = ocrText;
    void optimizeOcrText();
  }, [automationSettings.autoOptimizeOcr, isAutomationLoading, isOptimizingText, ocrText, optimizedText, optimizeOcrText]);

  // Update the active session's OCR state
  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update session state while optimization is in progress
    // This prevents saving incomplete/incorrect optimization results
    if (isOptimizingText) {
      return;
    }

    setSessions(prev => {
      if (!prev.find(s => s.id === activeSessionId)) {
        return prev;
      }

      return updateSessionInPlace(prev, activeSessionId, session => ({
        ...session,
        updatedAt: Date.now(),
        ocr: {
          imagePath,
          imagePreviewUrl,
          processedImageUrl,
          ocrText,
          optimizedText,
          textDisplayMode,
          params
        }
      }), sortBy);
    });
    // Note: isRestoringSessionRef excluded from deps - refs don't trigger re-renders
    // We read .current value inside the effect instead
  }, [activeSessionId, imagePath, imagePreviewUrl, processedImageUrl, ocrText, optimizedText, textDisplayMode, params, isOptimizingText, isSessionsLoading, setSessions, sortBy]);

  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update while optimization is in progress
    if (isOptimizing) {
      return;
    }

    setSessions(prev => {
      if (!prev.find(s => s.id === activeSessionId)) {
        return prev;
      }

      return updateSessionInPlace(prev, activeSessionId, session => ({
        ...session,
        updatedAt: Date.now(),
        prompt: {
          imageStyle,
          customDescription,
          optimizedPrompt
        }
      }), sortBy);
    });
    // Note: isRestoringSessionRef excluded from deps - refs don't trigger re-renders
  }, [activeSessionId, imageStyle, customDescription, optimizedPrompt, isOptimizing, isSessionsLoading, setSessions, sortBy]);

  useEffect(() => {
    if (isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    if (isGenerating) {
      return;
    }

    const targetSessionId = currentGenerationSessionIdRef.current ?? activeSessionId;
    if (!targetSessionId) {
      return;
    }

    setSessions(prev => {
      if (!prev.find(s => s.id === targetSessionId)) {
        return prev;
      }

      return updateSessionInPlace(prev, targetSessionId, session => ({
        ...session,
        updatedAt: Date.now(),
        generation: {
          aspectRatio,
          generatedImageUrl: '',
          generatedImageRemoteUrl,
          generatedImageLocalPath
        }
      }), sortBy);
    });

    if (currentGenerationSessionIdRef.current) {
      setCurrentGenerationSessionId(null);
      currentGenerationSessionIdRef.current = null;
    }
    // Note: isRestoringSessionRef excluded from deps - refs don't trigger re-renders
  }, [
    activeSessionId,
    aspectRatio,
    generatedImageLocalPath,
    generatedImageRemoteUrl,
    isGenerating,
    isSessionsLoading,
    setSessions,
    sortBy
  ]);

  // Track OCR state changes
  const previousOcrText = useRef<string>('');
  useEffect(() => {
    // Don't reset prompt when restoring a session
    if (isRestoringSessionRef.current) {
      return;
    }

    if (previousOcrText.current !== ocrText) {
      // OCR text changed - mark as performed if not empty
      if (ocrText) {
        setHasPerformedOcr(true);
      }

      // Reset prompt when OCR text changes, but keep the generated image
      // Users may want to keep the generated image even if OCR text changes
      if (previousOcrText.current) {
        setOptimizedPrompt('');
        // Don't reset generation state - let users manually clear if needed
      }

      previousOcrText.current = ocrText;
    }
    // Note: isRestoringSessionRef, previousOcrText excluded from deps
    // Refs don't trigger re-renders, we read .current inside effect
  }, [ocrText, setOptimizedPrompt]);

  const triggerImageGeneration = useCallback((prompt: string): boolean => {
    if (!activeSessionId) {
      return false;
    }

    if (!prompt.trim()) {
      return false;
    }

    if (isGenerating) {
      return false;
    }

    currentGenerationSessionIdRef.current = activeSessionId;
    setCurrentGenerationSessionId(activeSessionId);
    setGeneratedImageOwnerSessionId(activeSessionId);
    void generateImage(prompt);
    return true;
  }, [activeSessionId, generateImage, isGenerating, setGeneratedImageOwnerSessionId]);

  const handleGenerateImage = useCallback(() => {
    if (!optimizedPrompt.trim()) {
      return;
    }

    if (triggerImageGeneration(optimizedPrompt)) {
      lastAutoGeneratedImageRef.current = optimizedPrompt;
    }
  }, [optimizedPrompt, triggerImageGeneration]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGeneratePrompt || !ocrText.trim() || isRestoringSessionRef.current || isOptimizing) {
      return;
    }

    if (lastAutoPromptRef.current === ocrText) {
      return;
    }

    lastAutoPromptRef.current = ocrText;
    void optimizePrompt();
  }, [automationSettings.autoGeneratePrompt, isAutomationLoading, isOptimizing, ocrText, optimizePrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGenerateImage || !optimizedPrompt.trim() || isRestoringSessionRef.current || isGenerating) {
      return;
    }

    if (!activeSessionId) {
      return;
    }

    if (lastAutoGeneratedImageRef.current === optimizedPrompt) {
      return;
    }

    if (triggerImageGeneration(optimizedPrompt)) {
      lastAutoGeneratedImageRef.current = optimizedPrompt;
    }
  }, [activeSessionId, automationSettings.autoGenerateImage, isAutomationLoading, isGenerating, optimizedPrompt, triggerImageGeneration]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoSaveImage ||
        !automationSettings.autoSaveDirectory.trim() ||
        !generatedImageUrl ||
        isRestoringSessionRef.current) {
      return;
    }

    if (lastAutoSavedImageRef.current === generatedImageUrl) {
      return;
    }

    lastAutoSavedImageRef.current = generatedImageUrl;
    void saveGeneratedImageToDirectory(automationSettings.autoSaveDirectory).catch(() => {
      // Error already surfaced via generation status; no-op here.
    });
  }, [
    automationSettings.autoSaveDirectory,
    automationSettings.autoSaveImage,
    generatedImageUrl,
    isAutomationLoading,
    saveGeneratedImageToDirectory
  ]);

  const handleCopyPrompt = () => {
    if (!optimizedPrompt.trim()) {
      return;
    }

    navigator.clipboard.writeText(optimizedPrompt).catch(error => {
      console.error('Failed to copy optimized prompt:', error);
    });
  };

  const handleClearGeneratedImage = useCallback(() => {
    if (isGenerating) {
      return;
    }

    clearGeneratedImage();
    if (activeSessionId) {
      setGeneratedImageOwnerSessionId(activeSessionId);
    } else {
      setGeneratedImageOwnerSessionId(null);
    }
  }, [activeSessionId, clearGeneratedImage, isGenerating, setGeneratedImageOwnerSessionId]);


  const handleLanguageChange = (language: string) => {
    updateParam('language', language);
  };

  const gridClassName = MAIN_GRID_CLASS;
  const isActiveSessionGenerating = isGenerating && currentGenerationSessionId === activeSessionId;
  const isGenerationLocked = isGenerating;
  const ownsGeneratedImage = generatedImageOwnerSessionId === activeSessionId;
  const activeGeneratedImageUrl = ownsGeneratedImage ? generatedImageUrl : '';
  const activeGeneratedImageRemoteUrl = ownsGeneratedImage ? generatedImageRemoteUrl : '';

  useKeyboardShortcuts({
    onSelectImage: () => { void selectImage(); },
    onTakeScreenshot: () => { void takeScreenshot(); },
    onPerformOcr: () => { void performOCR(); },
    onCopyText: () => { void copyOcrText(); },
    onSaveText: () => {
      // Prioritize saving generated image, then OCR text
      if (activeGeneratedImageUrl) {
        void saveGeneratedImage();
      } else if (ocrText.trim()) {
        void saveOcrText();
      }
    },
    onOpenSettings: () => setIsSettingsOpen(true),
    onCloseModal: () => {
      if (isSettingsOpen) {
        setIsSettingsOpen(false);
      } else if (isSidebarOpen) {
        setIsSidebarOpen(false);
      }
    },
    canPerformOcr: Boolean(imagePath),
    hasOcrText: Boolean(ocrText.trim()),
    hasGeneratedImage: Boolean(activeGeneratedImageUrl)
  });

  const handleSelectSession = useCallback(async (sessionId: string) => {
    if (sessionId === activeSessionId) {
      setIsSidebarOpen(false);
      return;
    }

    // Set flags before calling session manager
    suppressAutoProcessRef.current = true;
    suppressPromptResetRef.current = true;

    try {
      const session = await sessionManagerSelectSession(sessionId);
      if (!session) {
        return;
      }

      setGeneratedImageOwnerSessionId(sessionId);

      // Check if session has any OCR data (text or processed image)
      const hasOcrData = Boolean(session.ocr.ocrText || session.ocr.processedImageUrl);
      setHasPerformedOcr(hasOcrData);

      // After restoring session, check if auto-processing is needed
      // This handles the case where OCR completed while this session was not active
      const sessionOcrText = session.ocr.ocrText?.trim() || '';
      const sessionOptimizedText = session.ocr.optimizedText?.trim() || '';
      const sessionOptimizedPrompt = session.prompt.optimizedPrompt?.trim() || '';

      // Reset auto-processing refs to allow processing for this restored session
      // This ensures that if OCR completed while session was inactive, auto-processing will trigger now
      // The useEffect hooks will check automationSettings and trigger auto-processing if needed
      if (sessionOcrText && !sessionOptimizedText) {
        lastAutoOptimizedOcrRef.current = '';
      }
      if (sessionOcrText && !sessionOptimizedPrompt) {
        lastAutoPromptRef.current = '';
      }
    } finally {
      // Reset flags after all async operations complete
      suppressAutoProcessRef.current = false;
      suppressPromptResetRef.current = false;
    }

    setIsSidebarOpen(false);
  }, [activeSessionId, sessionManagerSelectSession, setGeneratedImageOwnerSessionId]);

  const handleDeleteSession = useCallback((sessionId: string) => {
    const wasActiveSession = sessionManagerDeleteSession(sessionId);

    // If we deleted the active session, clear related state
    if (wasActiveSession) {
      setHasPerformedOcr(false);
      clearGeneratedImage();
      setGeneratedImageOwnerSessionId(null);
    }
  }, [sessionManagerDeleteSession, clearGeneratedImage, setGeneratedImageOwnerSessionId]);

  return (
    <ErrorBoundary>
      <div className="container">
        <ErrorNotification errors={errors} onErrorDismiss={clearError} />
      {imagePath && (
        <h1><span className="emoji">ðŸª„</span> Imagio  <span className="emoji">âœ¨</span></h1>
      )}

      <SidebarContainer
        isOpen={isSidebarOpen}
        onClose={() => setIsSidebarOpen(false)}
        automationSettings={automationSettings}
        onAutomationSettingChange={updateAutomationSetting}
        sessions={sessions}
        activeSessionId={activeSessionId}
        onSelectSession={handleSelectSession}
        onDeleteSession={handleDeleteSession}
        onSessionsChange={setSessions}
        onOpenSettings={() => {
          setIsSidebarOpen(false);
          setIsSettingsOpen(true);
        }}
        sortBy={sortBy}
        onSortByChange={setSortBy}
      />

      <SettingsContainer
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        llmSettings={llmSettings}
        onLLMSettingChange={(key: string, value: unknown) => updateLLMSetting(key as keyof typeof llmSettings, value as string | number)}
        bflApiKey={bflApiKey}
        onBflApiKeyChange={setBflApiKey}
        geminiApiKey={geminiApiKey}
        onGeminiApiKeyChange={setGeminiApiKey}
        bltcyApiKey={bltcyApiKey}
        onBltcyApiKeyChange={setBltcyApiKey}
        selectedModel={selectedModel}
        onSelectedModelChange={setSelectedModel}
        processingParams={params}
        onProcessingParamChange={(key: string, value: number | boolean | string) => updateParam(key as keyof typeof params, value)}
      />

      {imagePath && (
        <Toolbar
          onSelectImage={() => { void selectImage(); }}
          onTakeScreenshot={() => { void takeScreenshot(); }}
          language={params.language}
          onLanguageChange={handleLanguageChange}
          onOpenSettings={() => setIsSettingsOpen(true)}
          onToggleSidebar={() => setIsSidebarOpen(true)}
        />
      )}

      <ProcessingStatus isProcessing={isProcessing} statusMessage={processingStatus} />

      {imagePath ? (
        <div className={gridClassName}>
          <div className="left-panel">
            <OcrPreviewPanel
              imagePreviewUrl={imagePreviewUrl}
              processedImageUrl={processedImageUrl}
            />
          </div>

          <div className="middle-panel">
            {hasPerformedOcr && (
              <OcrTextPanel
                value={ocrText}
                onChange={updateOcrText}
                onCopy={() => copyOcrText()}
                onSave={() => saveOcrText()}
                optimizedText={optimizedText}
                isOptimizing={isOptimizingText}
                onOptimize={optimizeOcrText}
                textDisplayMode={textDisplayMode}
                onTextDisplayModeChange={setTextDisplayMode}
                onOptimizedTextChange={updateOptimizedText}
              />
            )}
          </div>

          {hasPerformedOcr && (
            <>
              <div className="right-panel">
                <PromptGenerationPanel
                  imageStyle={imageStyle}
                  onImageStyleChange={setImageStyle}
                  aspectRatio={aspectRatio}
                  onAspectRatioChange={setAspectRatio}
                  customDescription={customDescription}
                  onCustomDescriptionChange={setCustomDescription}
                  optimizedPrompt={optimizedPrompt}
                  onOptimizedPromptChange={setOptimizedPrompt}
                  onOptimize={optimizePrompt}
                  isOptimizing={isOptimizing}
                  llmError={llmError}
                  isOptimizeDisabled={!ocrText.trim()}
                  onCopyPrompt={handleCopyPrompt}
                  onGenerateImage={handleGenerateImage}
                  isGenerating={isActiveSessionGenerating}
                  isGenerationLocked={isGenerationLocked}
                />
              </div>

              <div className="generated-panel">
                <GeneratedImagePanel
                  generatedImageUrl={activeGeneratedImageUrl}
                  isGenerating={isActiveSessionGenerating}
                  generationStatus={generationStatus}
                  onSaveGeneratedImage={() => saveGeneratedImage()}
                  onCopyGeneratedImage={() => copyGeneratedImageToClipboard()}
                  onCopyGeneratedImageUrl={() => copyGeneratedImageUrl()}
                  onClearGeneratedImage={handleClearGeneratedImage}
                  hasRemoteImageUrl={Boolean(activeGeneratedImageRemoteUrl)}
                />
              </div>
            </>
          )}
        </div>
      ) : (
        <EmptyState
          onSelectImage={() => { void selectImage(); }}
          onTakeScreenshot={() => { void takeScreenshot(); }}
          language={params.language}
          onLanguageChange={handleLanguageChange}
          onOpenSettings={() => setIsSettingsOpen(true)}
          onToggleSidebar={() => setIsSidebarOpen(true)}
        />
      )}
      </div>
    </ErrorBoundary>
  );
};

export default App;
