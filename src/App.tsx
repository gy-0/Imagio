import { useCallback, useEffect, useRef, useState } from 'react';
import { DropOverlay } from './components/DropOverlay';
import { ProcessingStatus } from './components/ProcessingStatus';
import { Toolbar } from './components/toolbar/Toolbar';
import { OverlaySidebar } from './components/OverlaySidebar';
import { SettingsModal } from './components/SettingsModal';
import { useApplicationConfig } from './hooks/useApplicationConfig';
import { useAutomationSettings } from './hooks/useAutomationSettings';
import { useSessionStorage } from './hooks/useSessionStorage';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { OcrPreviewPanel } from './features/ocr/components/OcrPreviewPanel';
import { OcrTextPanel } from './features/ocr/components/OcrTextPanel';
import { useOcrProcessing } from './features/ocr/useOcrProcessing';
import { useImageGeneration } from './features/imageGeneration/useImageGeneration';
import { PromptGenerationPanel } from './features/promptOptimization/components/PromptGenerationPanel';
import { GeneratedImagePanel } from './features/promptOptimization/components/GeneratedImagePanel';
import { usePromptOptimization } from './features/promptOptimization/usePromptOptimization';
import { updateSessionInPlace, sortSessions, insertSessionSorted } from './utils/sessionUtils';
import type { SessionSource, AppSession } from './types/appSession';
import type { SortOption } from './utils/sessionUtils';
import { open as openDialog } from '@tauri-apps/plugin-dialog';
import { exists as fsExists, remove as fsRemove } from '@tauri-apps/plugin-fs';
import './App.css';

const App = () => {
  const [hasPerformedOcr, setHasPerformedOcr] = useState<boolean>(false);
  const [isSidebarOpen, setIsSidebarOpen] = useState<boolean>(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState<boolean>(false);
  const { sessions, setSessions, isLoading: isSessionsLoading } = useSessionStorage();
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const [sortBy, setSortBy] = useState<SortOption>('createdAt');
  const [currentGenerationSessionId, setCurrentGenerationSessionId] = useState<string | null>(null);
  const [generatedImageOwnerSessionId, setGeneratedImageOwnerSessionId] = useState<string | null>(null);
  const suppressAutoProcessRef = useRef<boolean>(false);
  const suppressPromptResetRef = useRef<boolean>(false);
  const isRestoringSessionRef = useRef<boolean>(false);
  const lastAutoOptimizedOcrRef = useRef<string>('');
  const lastAutoPromptRef = useRef<string>('');
  const lastAutoGeneratedImageRef = useRef<string>('');
  const lastAutoSavedImageRef = useRef<string>('');
  const onNewImageHandlerRef = useRef<((details: { path: string; previewUrl: string; source: 'file' | 'drop' | 'screenshot'; }) => string) | null>(null);
  const imagePathToSessionIdRef = useRef<Map<string, { sessionId: string; timestamp: number }>>(new Map());
  const MAX_MAPPING_ENTRIES = 100;
  const MAPPING_MAX_AGE_MS = 5 * 60 * 1000; // 5 minutes
  const optimizeOcrTextRef = useRef<(() => Promise<void>) | null>(null);
  const currentGenerationSessionIdRef = useRef<string | null>(null);
  // Use refs to avoid stale closure values in async callbacks
  const activeSessionIdRef = useRef<string | null>(null);
  // automationSettingsRef will be initialized after automationSettings is declared

  const {
    llmSettings,
    updateLLMSetting,
    bflApiKey,
    setBflApiKey,
    geminiApiKey,
    setGeminiApiKey,
    bltcyApiKey,
    setBltcyApiKey,
    selectedModel,
    setSelectedModel
  } = useApplicationConfig();
  const {
    settings: automationSettings,
    updateSetting: updateAutomationSetting,
    isLoading: isAutomationLoading
  } = useAutomationSettings();
  
  // Initialize automationSettingsRef after automationSettings is declared
  const automationSettingsRef = useRef(automationSettings);

  const {
    aspectRatio,
    setAspectRatio,
    generatedImageUrl,
    generatedImageRemoteUrl,
    generatedImageLocalPath,
    isGenerating,
    generationStatus,
    generateImage,
    saveGeneratedImage,
    copyGeneratedImageUrl,
    copyGeneratedImageToClipboard,
    clearGeneratedImage,
    saveGeneratedImageToDirectory,
    loadSessionSnapshot: loadGenerationSnapshot
  } = useImageGeneration({ bflApiKey, geminiApiKey, bltcyApiKey, selectedModel });

  const deleteSessionImageFile = useCallback(async (filePath: string) => {
    if (!filePath) {
      return;
    }

    try {
      const fileExists = await fsExists(filePath);
      if (fileExists) {
        await fsRemove(filePath);
      }
    } catch (error) {
      console.warn('Failed to delete generated image file:', filePath, error);
    }
  }, []);

  // Cleanup stale mapping entries
  const cleanupStaleMappings = useCallback(() => {
    const now = Date.now();
    const map = imagePathToSessionIdRef.current;

    for (const [path, entry] of map.entries()) {
      if (now - entry.timestamp > MAPPING_MAX_AGE_MS) {
        map.delete(path);
      }
    }

    // If still over capacity, remove oldest entries
    if (map.size > MAX_MAPPING_ENTRIES) {
      const entries = Array.from(map.entries())
        .sort((a, b) => a[1].timestamp - b[1].timestamp);

      const toRemove = entries.slice(0, map.size - MAX_MAPPING_ENTRIES);
      toRemove.forEach(([path]) => map.delete(path));
    }
  }, [MAX_MAPPING_ENTRIES, MAPPING_MAX_AGE_MS]);

  const handleOcrComplete = useCallback((details: { imagePath: string; ocrText: string; processedImageUrl: string; }) => {
    // Find the session ID for this image path
    const entry = imagePathToSessionIdRef.current.get(details.imagePath);
    if (!entry) {
      console.warn('No session found for image path:', details.imagePath);
      return;
    }
    const sessionId = entry.sessionId;

    // Use ref to get the latest activeSessionId to avoid stale closure values
    const currentActiveSessionId = activeSessionIdRef.current;
    const currentAutomationSettings = automationSettingsRef.current;

    // Update hasPerformedOcr if this is the active session
    if (sessionId === currentActiveSessionId) {
      setHasPerformedOcr(true);
    }

    // Update the session directly with OCR results
    // Keep the params from the session (including language setting)
    setSessions(prev => updateSessionInPlace(prev, sessionId, session => ({
      ...session,
      updatedAt: Date.now(),
      ocr: {
        ...session.ocr,
        processedImageUrl: details.processedImageUrl,
        ocrText: details.ocrText,
        // æ¸…ç©ºoptimizedTextï¼Œé˜²æ­¢æ—§å†…å®¹æ®‹ç•™
        optimizedText: '',
        textDisplayMode: 'original' as const
        // params remains from session.ocr.params - no change needed
      }
    }), sortBy));

    // è‡ªåŠ¨ä¼˜åŒ–ï¼šåªå¯¹å½“å‰æ´»åŠ¨sessionè§¦å‘ï¼Œä»¥ç¡®ä¿stateæ­£ç¡®åŒæ­¥
    // Use refs to check latest values instead of closure values
    if (sessionId === currentActiveSessionId && currentAutomationSettings.autoOptimizeOcr && details.ocrText.trim() && !isRestoringSessionRef.current) {
      // Mark this text as being optimized to prevent duplicate optimization
      lastAutoOptimizedOcrRef.current = details.ocrText;
      // Use the hook's optimizeOcrText function to ensure all state updates are synchronized
      void optimizeOcrTextRef.current?.();
    }

    // è‡ªåŠ¨ç”Ÿæˆprompt:å¦‚æžœè¿™æ˜¯å½“å‰active sessionä¸”å¼€å¯äº†auto-generate prompt
    // Use refs to check latest values instead of closure values
    if (sessionId === currentActiveSessionId && currentAutomationSettings.autoGeneratePrompt && details.ocrText.trim() && !isRestoringSessionRef.current) {
      // Reset the lastAutoPromptRef to allow auto-generation for the new image
      lastAutoPromptRef.current = '';
    }

    // Clean up the mapping
    imagePathToSessionIdRef.current.delete(details.imagePath);
  }, [setSessions, sortBy]);

  const handleOptimizeComplete = useCallback((details: { imagePath: string; optimizedText: string; }) => {
    // Find the session for this image path
    setSessions(prev => {
      const session = prev.find(s => s.ocr.imagePath === details.imagePath);
      if (!session) return prev;

      return updateSessionInPlace(prev, session.id, s => ({
        ...s,
        updatedAt: Date.now(),
        ocr: {
          ...s.ocr,
          optimizedText: details.optimizedText,
          textDisplayMode: 'optimized' as const
        }
      }), sortBy);
    });
  }, [sortBy]);

  const handleOcrError = useCallback((details: { imagePath: string; error: string; }) => {
    // Clean up the mapping to prevent memory leak
    imagePathToSessionIdRef.current.delete(details.imagePath);
    console.error('OCR processing failed:', details.error, 'for image:', details.imagePath);
  }, []);

  const {
    imagePath,
    imagePreviewUrl,
    processedImageUrl,
    ocrText,
    updateOcrText,
    optimizedText,
    updateOptimizedText,
    isOptimizingText,
    textDisplayMode,
    setTextDisplayMode,
    optimizeOcrText,
    isProcessing,
    processingStatus,
    params,
    updateParam,
    selectImage,
    takeScreenshot,
    performOCR,
    copyOcrText,
    saveOcrText,
    isDragging,
    dragAndDropHandlers,
    loadSessionSnapshot: loadOcrSnapshot
  } = useOcrProcessing({
    llmSettings,
    suppressAutoProcessRef,
    onNewImage: (details) => {
      return onNewImageHandlerRef.current?.(details) ?? '';
    },
    onOcrComplete: handleOcrComplete,
    onOcrError: handleOcrError,
    onOptimizeComplete: handleOptimizeComplete
  });

  const {
    imageStyle,
    customDescription,
    optimizedPrompt,
    isOptimizing,
    llmError,
    setImageStyle,
    setCustomDescription,
    setOptimizedPrompt,
    optimizePrompt,
    loadSessionSnapshot: loadPromptSnapshot
  } = usePromptOptimization(llmSettings, ocrText, {
    suppressOcrResetRef: suppressPromptResetRef
  });

  const generateSessionId = useCallback(() => {
    if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
      return crypto.randomUUID();
    }
    return `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }, []);

  const deriveSessionTitle = useCallback((path: string, source: SessionSource) => {
    if (path) {
      const parts = path.split(/[/\\]/);
      const filename = parts[parts.length - 1];
      if (filename) {
        return filename;
      }
    }

    const timestamp = new Date().toLocaleTimeString();
    switch (source) {
      case 'screenshot':
        return `Screenshot ${timestamp}`;
      case 'drop':
        return `Drag & Drop ${timestamp}`;
      default:
        return `Session ${timestamp}`;
    }
  }, []);

  const handleNewImage = useCallback((details: { path: string; previewUrl: string; source: SessionSource; }) => {
    const sessionId = generateSessionId();
    const timestamp = Date.now();
    const newSession: AppSession = {
      id: sessionId,
      title: deriveSessionTitle(details.path, details.source),
      createdAt: timestamp,
      updatedAt: timestamp,
      source: details.source,
      ocr: {
        imagePath: details.path,
        imagePreviewUrl: details.previewUrl,
        processedImageUrl: '',
        ocrText: '',
        optimizedText: '',
        textDisplayMode: 'original',
        params
      },
      prompt: {
        imageStyle,
        customDescription,
        optimizedPrompt: ''
      },
      generation: {
        aspectRatio,
        generatedImageUrl: '',
        generatedImageRemoteUrl: '',
        generatedImageLocalPath: ''
      }
    };

    setSessions(prev => insertSessionSorted(prev, newSession, sortBy));
    setActiveSessionId(sessionId);
    setHasPerformedOcr(false);
    setGeneratedImageOwnerSessionId(sessionId);
  void loadGenerationSnapshot(newSession.generation);

    // Track the mapping from image path to session ID with timestamp
    // Clean up old entries before adding new one
    cleanupStaleMappings();
    imagePathToSessionIdRef.current.set(details.path, {
      sessionId,
      timestamp: Date.now()
    });

    lastAutoOptimizedOcrRef.current = '';
    lastAutoPromptRef.current = '';
    lastAutoGeneratedImageRef.current = '';
    lastAutoSavedImageRef.current = '';

    // Return the session ID so caller can update the session later
    return sessionId;
  }, [aspectRatio, cleanupStaleMappings, customDescription, deriveSessionTitle, generateSessionId, imageStyle, loadGenerationSnapshot, params, setGeneratedImageOwnerSessionId, sortBy]);

  useEffect(() => {
    onNewImageHandlerRef.current = handleNewImage;
  }, [handleNewImage]);

  useEffect(() => {
    optimizeOcrTextRef.current = optimizeOcrText;
  }, [optimizeOcrText]);

  // Keep refs in sync with state to avoid stale closures
  useEffect(() => {
    activeSessionIdRef.current = activeSessionId;
  }, [activeSessionId]);

  useEffect(() => {
    automationSettingsRef.current = automationSettings;
  }, [automationSettings]);

  // Cleanup mapping table on unmount
  useEffect(() => {
    return () => {
      imagePathToSessionIdRef.current.clear();
    };
  }, []);

  // Re-sort sessions when sortBy changes
  // Note: This only triggers when user explicitly changes sort option
  // Performance: O(n log n) but n is typically small (<50 sessions)
  useEffect(() => {
    setSessions(prev => {
      // Avoid unnecessary re-sort if already sorted by this criterion
      // Check if first two elements are in correct order (heuristic)
      if (prev.length >= 2 && prev[0][sortBy] >= prev[1][sortBy]) {
        // Likely already sorted, but verify with full check
        const isSorted = prev.every((session, i) =>
          i === 0 || prev[i - 1][sortBy] >= session[sortBy]
        );
        if (isSorted) {
          return prev; // No need to re-sort
        }
      }
      return sortSessions(prev, sortBy);
    });
  }, [sortBy, setSessions]);

  // Auto-optimize when setting is enabled and OCR text exists without optimization
  // This works in conjunction with handleOcrComplete to support two scenarios:
  // 1. Auto-optimize on OCR completion (handled in handleOcrComplete)
  // 2. Auto-optimize when user enables the setting after OCR is complete (handled here)
  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoOptimizeOcr || !ocrText.trim() || isRestoringSessionRef.current || isOptimizingText) {
      return;
    }

    // Only auto-optimize if there's no optimized text yet
    // This prevents duplicate optimization when handleOcrComplete already optimized
    if (optimizedText.trim()) {
      return;
    }

    if (lastAutoOptimizedOcrRef.current === ocrText) {
      return;
    }

    lastAutoOptimizedOcrRef.current = ocrText;
    void optimizeOcrText();
  }, [automationSettings.autoOptimizeOcr, isAutomationLoading, isOptimizingText, ocrText, optimizedText, optimizeOcrText]);

  // Update the active session's OCR state
  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update session state while optimization is in progress
    // This prevents saving incomplete/incorrect optimization results
    if (isOptimizingText) {
      return;
    }

    setSessions(prev => {
      if (!prev.find(s => s.id === activeSessionId)) {
        return prev;
      }

      return updateSessionInPlace(prev, activeSessionId, session => ({
        ...session,
        updatedAt: Date.now(),
        ocr: {
          imagePath,
          imagePreviewUrl,
          processedImageUrl,
          ocrText,
          optimizedText,
          textDisplayMode,
          params
        }
      }), sortBy);
    });
    // Note: isRestoringSessionRef excluded from deps - refs don't trigger re-renders
    // We read .current value inside the effect instead
  }, [activeSessionId, imagePath, imagePreviewUrl, processedImageUrl, ocrText, optimizedText, textDisplayMode, params, isOptimizingText, isSessionsLoading, setSessions, sortBy]);

  useEffect(() => {
    if (!activeSessionId || isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    // Don't update while optimization is in progress
    if (isOptimizing) {
      return;
    }

    setSessions(prev => {
      if (!prev.find(s => s.id === activeSessionId)) {
        return prev;
      }

      return updateSessionInPlace(prev, activeSessionId, session => ({
        ...session,
        updatedAt: Date.now(),
        prompt: {
          imageStyle,
          customDescription,
          optimizedPrompt
        }
      }), sortBy);
    });
    // Note: isRestoringSessionRef excluded from deps - refs don't trigger re-renders
  }, [activeSessionId, imageStyle, customDescription, optimizedPrompt, isOptimizing, isSessionsLoading, setSessions, sortBy]);

  useEffect(() => {
    if (isRestoringSessionRef.current || isSessionsLoading) {
      return;
    }

    if (isGenerating) {
      return;
    }

    const targetSessionId = currentGenerationSessionIdRef.current ?? activeSessionId;
    if (!targetSessionId) {
      return;
    }

    setSessions(prev => {
      if (!prev.find(s => s.id === targetSessionId)) {
        return prev;
      }

      return updateSessionInPlace(prev, targetSessionId, session => ({
        ...session,
        updatedAt: Date.now(),
        generation: {
          aspectRatio,
          generatedImageUrl: '',
          generatedImageRemoteUrl,
          generatedImageLocalPath
        }
      }), sortBy);
    });

    if (currentGenerationSessionIdRef.current) {
      setCurrentGenerationSessionId(null);
      currentGenerationSessionIdRef.current = null;
    }
    // Note: isRestoringSessionRef excluded from deps - refs don't trigger re-renders
  }, [
    activeSessionId,
    aspectRatio,
    generatedImageLocalPath,
    generatedImageRemoteUrl,
    isGenerating,
    isSessionsLoading,
    setSessions,
    sortBy
  ]);

  // Track OCR state changes
  const previousOcrText = useRef<string>('');
  useEffect(() => {
    // Don't reset prompt when restoring a session
    if (isRestoringSessionRef.current) {
      return;
    }

    if (previousOcrText.current !== ocrText) {
      // OCR text changed - mark as performed if not empty
      if (ocrText) {
        setHasPerformedOcr(true);
      }

      // Reset prompt when OCR text changes, but keep the generated image
      // Users may want to keep the generated image even if OCR text changes
      if (previousOcrText.current) {
        setOptimizedPrompt('');
        // Don't reset generation state - let users manually clear if needed
      }

      previousOcrText.current = ocrText;
    }
    // Note: isRestoringSessionRef, previousOcrText excluded from deps
    // Refs don't trigger re-renders, we read .current inside effect
  }, [ocrText, setOptimizedPrompt]);

  const triggerImageGeneration = useCallback((prompt: string): boolean => {
    if (!activeSessionId) {
      return false;
    }

    if (!prompt.trim()) {
      return false;
    }

    if (isGenerating) {
      return false;
    }

    currentGenerationSessionIdRef.current = activeSessionId;
    setCurrentGenerationSessionId(activeSessionId);
    setGeneratedImageOwnerSessionId(activeSessionId);
    void generateImage(prompt);
    return true;
  }, [activeSessionId, generateImage, isGenerating, setGeneratedImageOwnerSessionId]);

  const handleGenerateImage = useCallback(() => {
    if (!optimizedPrompt.trim()) {
      return;
    }

    if (triggerImageGeneration(optimizedPrompt)) {
      lastAutoGeneratedImageRef.current = optimizedPrompt;
    }
  }, [optimizedPrompt, triggerImageGeneration]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGeneratePrompt || !ocrText.trim() || isRestoringSessionRef.current || isOptimizing) {
      return;
    }

    if (lastAutoPromptRef.current === ocrText) {
      return;
    }

    lastAutoPromptRef.current = ocrText;
    void optimizePrompt();
  }, [automationSettings.autoGeneratePrompt, isAutomationLoading, isOptimizing, ocrText, optimizePrompt]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoGenerateImage || !optimizedPrompt.trim() || isRestoringSessionRef.current || isGenerating) {
      return;
    }

    if (!activeSessionId) {
      return;
    }

    if (lastAutoGeneratedImageRef.current === optimizedPrompt) {
      return;
    }

    if (triggerImageGeneration(optimizedPrompt)) {
      lastAutoGeneratedImageRef.current = optimizedPrompt;
    }
  }, [activeSessionId, automationSettings.autoGenerateImage, isAutomationLoading, isGenerating, optimizedPrompt, triggerImageGeneration]);

  useEffect(() => {
    if (isAutomationLoading) {
      return;
    }

    if (!automationSettings.autoSaveImage ||
        !automationSettings.autoSaveDirectory.trim() ||
        !generatedImageUrl ||
        isRestoringSessionRef.current) {
      return;
    }

    if (lastAutoSavedImageRef.current === generatedImageUrl) {
      return;
    }

    lastAutoSavedImageRef.current = generatedImageUrl;
    void saveGeneratedImageToDirectory(automationSettings.autoSaveDirectory).catch(() => {
      // Error already surfaced via generation status; no-op here.
    });
  }, [
    automationSettings.autoSaveDirectory,
    automationSettings.autoSaveImage,
    generatedImageUrl,
    isAutomationLoading,
    saveGeneratedImageToDirectory
  ]);

  const handleCopyPrompt = () => {
    if (!optimizedPrompt.trim()) {
      return;
    }

    navigator.clipboard.writeText(optimizedPrompt).catch(error => {
      console.error('Failed to copy optimized prompt:', error);
    });
  };

  const handleClearGeneratedImage = useCallback(() => {
    if (isGenerating) {
      return;
    }

    clearGeneratedImage();
    if (activeSessionId) {
      setGeneratedImageOwnerSessionId(activeSessionId);
    } else {
      setGeneratedImageOwnerSessionId(null);
    }
  }, [activeSessionId, clearGeneratedImage, isGenerating, setGeneratedImageOwnerSessionId]);

  const handleSelectAutoSaveDirectory = useCallback(async () => {
    try {
      const selected = await openDialog({
        directory: true,
        multiple: false,
        defaultPath: automationSettings.autoSaveDirectory || undefined
      });

      if (typeof selected === 'string' && selected.trim()) {
        updateAutomationSetting('autoSaveDirectory', selected);
      }
    } catch (error) {
      console.error('Failed to select auto-save directory:', error);
    }
  }, [automationSettings.autoSaveDirectory, updateAutomationSetting]);

  const handleLanguageChange = (language: string) => {
    updateParam('language', language);
  };

  const gridClassName = 'main-content-three-column has-generated';
  const isActiveSessionGenerating = isGenerating && currentGenerationSessionId === activeSessionId;
  const isGenerationLocked = isGenerating;
  const ownsGeneratedImage = generatedImageOwnerSessionId === activeSessionId;
  const activeGeneratedImageUrl = ownsGeneratedImage ? generatedImageUrl : '';
  const activeGeneratedImageRemoteUrl = ownsGeneratedImage ? generatedImageRemoteUrl : '';

  useKeyboardShortcuts({
    onSelectImage: () => { void selectImage(); },
    onTakeScreenshot: () => { void takeScreenshot(); },
    onPerformOcr: () => { void performOCR(); },
    onCopyText: () => { void copyOcrText(); },
    onSaveText: () => {
      // Prioritize saving generated image, then OCR text
      if (activeGeneratedImageUrl) {
        void saveGeneratedImage();
      } else if (ocrText.trim()) {
        void saveOcrText();
      }
    },
    onOpenSettings: () => setIsSettingsOpen(true),
    onCloseModal: () => {
      if (isSettingsOpen) {
        setIsSettingsOpen(false);
      } else if (isSidebarOpen) {
        setIsSidebarOpen(false);
      }
    },
    canPerformOcr: Boolean(imagePath),
    hasOcrText: Boolean(ocrText.trim()),
    hasGeneratedImage: Boolean(activeGeneratedImageUrl)
  });

  const handleSelectSession = useCallback((sessionId: string) => {
    if (sessionId === activeSessionId) {
      setIsSidebarOpen(false);
      return;
    }

    const session = sessions.find(item => item.id === sessionId);
    if (!session) {
      return;
    }

    // Prevent switching while already restoring
    if (isRestoringSessionRef.current) {
      console.log('Session restore already in progress, ignoring click');
      return;
    }

    const restoreSession = async () => {
      isRestoringSessionRef.current = true;
      suppressAutoProcessRef.current = true;
      suppressPromptResetRef.current = true;

      try {
        // First set the active session ID before loading snapshots
        // This ensures the effects know which session is being restored
        setActiveSessionId(sessionId);

        // Wait for all snapshot loading operations to complete
        // This ensures state is fully synchronized before resetting flags
        await Promise.all([
          Promise.resolve(loadOcrSnapshot(session.ocr)),
          Promise.resolve(loadPromptSnapshot(session.prompt)),
          loadGenerationSnapshot(session.generation)
        ]);

        setGeneratedImageOwnerSessionId(sessionId);

        // Check if session has any OCR data (text or processed image)
        const hasOcrData = Boolean(session.ocr.ocrText || session.ocr.processedImageUrl);
        setHasPerformedOcr(hasOcrData);

        setSessions(prev => updateSessionInPlace(prev, sessionId, session => ({
          ...session,
          updatedAt: Date.now()
        }), sortBy));

        // Wait for next tick to ensure all setState calls have been processed
        await new Promise(resolve => setTimeout(resolve, 0));

        // After restoring session, check if auto-processing is needed
        // This handles the case where OCR completed while this session was not active
        const sessionOcrText = session.ocr.ocrText?.trim() || '';
        const sessionOptimizedText = session.ocr.optimizedText?.trim() || '';
        const sessionOptimizedPrompt = session.prompt.optimizedPrompt?.trim() || '';

        // Reset auto-processing refs to allow processing for this restored session
        // This ensures that if OCR completed while session was inactive, auto-processing will trigger now
        // The useEffect hooks will check automationSettings and trigger auto-processing if needed
        if (sessionOcrText && !sessionOptimizedText) {
          lastAutoOptimizedOcrRef.current = '';
        }
        if (sessionOcrText && !sessionOptimizedPrompt) {
          lastAutoPromptRef.current = '';
        }
      } finally {
        // Reset flags after all async operations complete
        suppressAutoProcessRef.current = false;
        suppressPromptResetRef.current = false;
        isRestoringSessionRef.current = false;
      }
    };

    void restoreSession();
    setIsSidebarOpen(false);
  }, [
    activeSessionId,
    sessions,
    loadOcrSnapshot,
    loadPromptSnapshot,
    loadGenerationSnapshot,
    suppressAutoProcessRef,
    suppressPromptResetRef,
    sortBy
  ]);

  const handleDeleteSession = useCallback((sessionId: string) => {
    setSessions(prev => {
      const sessionToDelete = prev.find(session => session.id === sessionId);
      if (sessionToDelete?.generation.generatedImageLocalPath) {
        void deleteSessionImageFile(sessionToDelete.generation.generatedImageLocalPath);
      }
      return prev.filter(session => session.id !== sessionId);
    });

    // If we deleted the active session, clear the active session
    if (sessionId === activeSessionId) {
      setActiveSessionId(null);
      setHasPerformedOcr(false);
      clearGeneratedImage();
      setGeneratedImageOwnerSessionId(null);
    }
  }, [activeSessionId, clearGeneratedImage, deleteSessionImageFile, setGeneratedImageOwnerSessionId, setSessions]);

  return (
    <div
      className="container"
      {...dragAndDropHandlers}
    >
      <h1><span className="emoji">ðŸª„</span> Imagio  <span className="emoji">âœ¨</span></h1>

      <DropOverlay isVisible={isDragging} />

      <OverlaySidebar
        isOpen={isSidebarOpen}
        onClose={() => setIsSidebarOpen(false)}
        automationSettings={automationSettings}
        onAutomationSettingChange={updateAutomationSetting}
        onSelectAutoSaveDirectory={() => { void handleSelectAutoSaveDirectory(); }}
        sessions={sessions}
        activeSessionId={activeSessionId}
        onSelectSession={handleSelectSession}
        onDeleteSession={handleDeleteSession}
        onOpenSettings={() => {
          setIsSidebarOpen(false);
          setIsSettingsOpen(true);
        }}
        sortBy={sortBy}
        onSortByChange={setSortBy}
      />

      <SettingsModal
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        llmSettings={llmSettings}
        onLLMSettingChange={updateLLMSetting}
        bflApiKey={bflApiKey}
        onBflApiKeyChange={setBflApiKey}
        geminiApiKey={geminiApiKey}
        onGeminiApiKeyChange={setGeminiApiKey}
        bltcyApiKey={bltcyApiKey}
        onBltcyApiKeyChange={setBltcyApiKey}
        selectedModel={selectedModel}
        onSelectedModelChange={setSelectedModel}
        processingParams={params}
        onProcessingParamChange={updateParam}
      />

      <Toolbar
        onSelectImage={() => { void selectImage(); }}
        onTakeScreenshot={() => { void takeScreenshot(); }}
        language={params.language}
        onLanguageChange={handleLanguageChange}
        onOpenSettings={() => setIsSettingsOpen(true)}
        onToggleSidebar={() => setIsSidebarOpen(true)}
      />

      <ProcessingStatus isProcessing={isProcessing} statusMessage={processingStatus} />

      {imagePath && (
        <div className={gridClassName}>
          <div className="left-panel">
            <OcrPreviewPanel
              imagePreviewUrl={imagePreviewUrl}
              processedImageUrl={processedImageUrl}
            />
          </div>

          <div className="middle-panel">
            {hasPerformedOcr && (
              <OcrTextPanel
                value={ocrText}
                onChange={updateOcrText}
                onCopy={() => copyOcrText()}
                onSave={() => saveOcrText()}
                optimizedText={optimizedText}
                isOptimizing={isOptimizingText}
                onOptimize={optimizeOcrText}
                textDisplayMode={textDisplayMode}
                onTextDisplayModeChange={setTextDisplayMode}
                onOptimizedTextChange={updateOptimizedText}
              />
            )}
          </div>

          {hasPerformedOcr && (
            <>
              <div className="right-panel">
                <PromptGenerationPanel
                  imageStyle={imageStyle}
                  onImageStyleChange={setImageStyle}
                  aspectRatio={aspectRatio}
                  onAspectRatioChange={setAspectRatio}
                  customDescription={customDescription}
                  onCustomDescriptionChange={setCustomDescription}
                  optimizedPrompt={optimizedPrompt}
                  onOptimizedPromptChange={setOptimizedPrompt}
                  onOptimize={optimizePrompt}
                  isOptimizing={isOptimizing}
                  llmError={llmError}
                  isOptimizeDisabled={!ocrText.trim()}
                  onCopyPrompt={handleCopyPrompt}
                  onGenerateImage={handleGenerateImage}
                  isGenerating={isActiveSessionGenerating}
                  isGenerationLocked={isGenerationLocked}
                />
              </div>

              <div className="generated-panel">
                <GeneratedImagePanel
                  generatedImageUrl={activeGeneratedImageUrl}
                  isGenerating={isActiveSessionGenerating}
                  generationStatus={generationStatus}
                  onSaveGeneratedImage={() => saveGeneratedImage()}
                  onCopyGeneratedImage={() => copyGeneratedImageToClipboard()}
                  onCopyGeneratedImageUrl={() => copyGeneratedImageUrl()}
                  onClearGeneratedImage={handleClearGeneratedImage}
                  hasRemoteImageUrl={Boolean(activeGeneratedImageRemoteUrl)}
                />
              </div>
            </>
          )}
        </div>
      )}
    </div>
  );
};

export default App;
