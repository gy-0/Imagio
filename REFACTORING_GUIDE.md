# 代码重构指南

## 概述

本次重构旨在解决以下问题：
1. ✅ **App.tsx过于复杂** - 940行代码，17个state，14个effect
2. ✅ **过度使用refs避免闭包** - 10+个ref用于状态同步
3. ✅ **localStorage配额风险** - 图片持久化问题
4. ✅ **TypeScript类型安全** - 移除13处`any`类型
5. ✅ **路径验证** - 防止路径遍历攻击

## 已完成的改进

### 1. 创建Context管理全局状态

#### SessionContext (`src/context/SessionContext.tsx`)
管理所有会话相关的状态和操作：

**提供的状态**:
- `sessions: AppSession[]` - 所有会话列表
- `activeSessionId: string | null` - 当前活跃会话ID
- `sortBy: SortOption` - 排序方式
- `isSessionsLoading: boolean` - 加载状态

**提供的方法**:
- `createSession()` - 创建新会话
- `updateSession()` - 更新会话信息
- `deleteSession()` - 删除会话
- `setActiveSessionId()` - 切换活跃会话

**提供的Refs** (避免闭包问题):
- `activeSessionIdRef` - 最新的activeSessionId
- `sessionsRef` - 最新的sessions数组

#### AutomationContext (`src/context/AutomationContext.tsx`)
管理自动化设置和控制标志：

**提供的状态**:
- `settings: AutomationSettings` - 自动化设置
- `isLoading: boolean` - 加载状态

**提供的控制Refs**:
- `suppressAutoProcessRef` - 抑制自动处理
- `suppressPromptResetRef` - 抑制prompt重置
- `isRestoringSessionRef` - 会话恢复中
- `lastAutoOptimizedOcrRef` - 上次自动优化的OCR文本
- `lastAutoPromptRef` - 上次自动生成的prompt
- `lastAutoGeneratedImageRef` - 上次自动生成的图片
- `lastAutoSavedImageRef` - 上次自动保存的图片
- `settingsRef` - 最新的settings

### 2. 创建业务逻辑Hooks

#### useOcrWorkflow (`src/hooks/useOcrWorkflow.ts`)
封装OCR工作流逻辑：
- 图片路径到会话ID的映射管理
- OCR完成处理
- 自动优化触发
- 错误处理

**使用示例**:
```typescript
const {
  registerImagePath,
  handleOcrComplete,
  handleOptimizeComplete,
  handleOcrError,
  optimizeOcrTextRef
} = useOcrWorkflow();

// 注册图片路径
registerImagePath(imagePath, sessionId);

// OCR完成后调用
handleOcrComplete({
  imagePath,
  ocrText,
  processedImageUrl
});
```

### 3. 图片持久化修复

#### 问题分析
- **Original Image**: 保存用户文件路径 → ✅ 永久有效
- **Processed Image**: 保存在`/tmp/` → ⚠️ 可能被系统清理
- **Generated Image**: 保存在app data目录 → ✅ 永久有效

#### 解决方案 (`src/hooks/useSessionStorage.ts`)
```typescript
// 保存到localStorage时
const sanitizedSessions = sessionsToSave.map(session => ({
  ...session,
  ocr: {
    ...session.ocr,
    // 保留文件路径，仅清理blob URL
    imagePreviewUrl: session.ocr.imagePreviewUrl.startsWith('blob:')
      ? '' : session.ocr.imagePreviewUrl,
    processedImageUrl: session.ocr.processedImageUrl.startsWith('blob:')
      ? '' : session.ocr.processedImageUrl,
  },
  generation: {
    ...session.generation,
    // 保留本地文件路径和远程URL
    generatedImageLocalPath: session.generation.generatedImageLocalPath || '',
    generatedImageRemoteUrl: session.generation.generatedImageRemoteUrl || ''
  }
}));
```

**详细说明**: 见 `PERSISTENT_IMAGES_NOTE.md`

### 4. TypeScript类型安全改进

#### llmClient.ts修复
```typescript
// ❌ 之前
function validateLLMResponse(parsed: any): LLMResponseValidation

// ✅ 现在
interface LLMResponseStructure {
  choices?: Array<{
    message?: { content?: unknown };
    text?: unknown;
  }>;
  usage?: { ... };
}

function validateLLMResponse(parsed: unknown): LLMResponseValidation {
  const response = parsed as LLMResponseStructure;
  // 完整的类型守卫
}
```

#### imageGenClient.ts修复
```typescript
// ❌ 之前
const requestBody: Record<string, any> = { ... }

// ✅ 现在
const requestBody: Record<string, unknown> = { ... }
```

#### useImageGeneration.ts修复
```typescript
// ❌ 之前
model: apiModel as any

// ✅ 现在
model: apiModel as 'flux-pro' | 'flux-dev' | 'flux-schnell'
```

### 5. 路径验证防护

#### Rust后端改进 (`src-tauri/src/lib.rs`)
```rust
#[tauri::command]
async fn save_text_to_path(text: String, file_path: String) -> Result<(), String> {
    use std::path::Path;

    let path = Path::new(&file_path);

    // 验证父目录存在
    let parent_dir = path.parent()
        .ok_or_else(|| "Invalid file path: no parent directory".to_string())?;

    if !parent_dir.exists() {
        return Err(format!("Parent directory does not exist"));
    }

    // 规范化路径，防止 ../ 攻击
    let canonical_parent = parent_dir.canonicalize()
        .map_err(|e| format!("Failed to resolve parent path: {}", e))?;

    let canonical_path = canonical_parent.join(
        path.file_name().ok_or_else(|| "Invalid file name".to_string())?
    );

    fs::write(&canonical_path, text)
        .map_err(|e| format!("Failed to save file: {}", e))?;

    Ok(())
}
```

### 6. 开发日志工具

#### logger工具 (`src/utils/logger.ts`)
```typescript
import { logger } from './utils/logger';

// 开发环境会输出，生产环境自动静默
logger.debug('OCR processing started', { imagePath });
logger.info('Session created', { sessionId });
logger.warn('Large session count', { count });
logger.error('Failed to save', { error });

// 性能日志
logger.perf('OCR processing', () => {
  // 执行OCR
});

// 异步性能日志
await logger.perfAsync('Image generation', async () => {
  return await generateImage(prompt);
});
```

**特性**:
- ✅ 基于`import.meta.env.DEV`自动判断环境
- ✅ 生产环境仅保留error和warn
- ✅ 支持性能监控
- ✅ 支持分组日志

## 如何继续重构App.tsx

### 当前App.tsx问题
- 940行代码
- 17个useState
- 14个useEffect
- 10+个useRef
- 大量重复的状态更新逻辑

### 推荐的重构步骤

#### 第1步: 使用新的Context (已完成基础设施)

```typescript
// App.tsx顶部
import { useSessionContext } from './context/SessionContext';
import { useAutomationContext } from './context/AutomationContext';
import { useOcrWorkflow } from './hooks/useOcrWorkflow';

function App() {
  // 替换原来的 sessions, activeSessionId等
  const {
    sessions,
    activeSessionId,
    setActiveSessionId,
    createSession,
    updateSession,
    deleteSession,
    activeSessionIdRef  // 用于避免闭包
  } = useSessionContext();

  // 替换原来的 automationSettings和相关refs
  const {
    settings: automationSettings,
    updateSetting: updateAutomationSetting,
    suppressAutoProcessRef,
    isRestoringSessionRef,
    lastAutoOptimizedOcrRef,
    // ... 其他refs
  } = useAutomationContext();

  // 使用OCR工作流hook
  const {
    registerImagePath,
    handleOcrComplete,
    handleOptimizeComplete,
    handleOcrError
  } = useOcrWorkflow();

  // 剩余的组件逻辑...
}
```

#### 第2步: 提取图片生成工作流

创建 `src/hooks/useImageGenerationWorkflow.ts`:
```typescript
export const useImageGenerationWorkflow = () => {
  const { activeSessionId, updateSession } = useSessionContext();
  const {
    settings,
    lastAutoGeneratedImageRef,
    lastAutoSavedImageRef
  } = useAutomationContext();

  const {
    generateImage,
    generatedImageUrl,
    isGenerating
  } = useImageGeneration({ ... });

  const triggerImageGeneration = useCallback((prompt: string) => {
    // 集中处理图片生成逻辑
  }, [...]);

  // 自动保存逻辑
  useEffect(() => {
    if (settings.autoSaveImage && generatedImageUrl) {
      // 自动保存
    }
  }, [settings.autoSaveImage, generatedImageUrl]);

  return {
    triggerImageGeneration,
    generatedImageUrl,
    isGenerating
  };
};
```

#### 第3步: 提取会话恢复逻辑

创建 `src/hooks/useSessionRestore.ts`:
```typescript
export const useSessionRestore = () => {
  const { setActiveSessionId } = useSessionContext();
  const { isRestoringSessionRef, suppressAutoProcessRef } = useAutomationContext();

  const restoreSession = useCallback(async (session: AppSession) => {
    isRestoringSessionRef.current = true;
    suppressAutoProcessRef.current = true;

    try {
      await loadOcrSnapshot(session.ocr);
      await loadPromptSnapshot(session.prompt);
      await loadGenerationSnapshot(session.generation);
      setActiveSessionId(session.id);
    } finally {
      suppressAutoProcessRef.current = false;
      isRestoringSessionRef.current = false;
    }
  }, [...]);

  return { restoreSession };
};
```

#### 第4步: 简化组件结构

```typescript
function App() {
  // 1. Contexts (6行 vs 原来的30+行state/refs)
  const session = useSessionContext();
  const automation = useAutomationContext();
  const config = useApplicationConfig();
  const ocrWorkflow = useOcrWorkflow();
  const imageWorkflow = useImageGenerationWorkflow();
  const sessionRestore = useSessionRestore();

  // 2. 业务逻辑hooks (原来的功能都在hooks中)
  const {
    imagePath,
    ocrText,
    performOCR,
    selectImage,
    takeScreenshot
  } = useOcrProcessing({ ... });

  const {
    optimizedPrompt,
    optimizePrompt,
    setImageStyle
  } = usePromptOptimization(config.llmSettings, ocrText);

  // 3. UI状态 (仅保留纯UI相关)
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [hasPerformedOcr, setHasPerformedOcr] = useState(false);

  // 4. 简化的effects
  // 大部分effects移到了hooks中

  // 5. 渲染（保持不变）
  return (
    <ErrorBoundary>
      {/* JSX */}
    </ErrorBoundary>
  );
}
```

### 预期效果
- App.tsx: 940行 → 约400-500行
- useState: 17个 → 约5-7个
- useEffect: 14个 → 约3-5个
- useRef: 10+个 → 0个（全部在Context中）
- 可测试性: 大幅提升
- 可维护性: 大幅提升

## 测试重构后的代码

### 1. 功能测试清单
- [ ] 图片选择和OCR处理
- [ ] 会话创建和切换
- [ ] 自动化流程（auto-optimize, auto-generate, auto-save）
- [ ] 图片生成
- [ ] 会话删除
- [ ] 历史记录恢复（重启后）
- [ ] 设置保存

### 2. 性能测试
- [ ] localStorage配额不超限
- [ ] 图片持久化正常
- [ ] 无内存泄漏（blob URL清理）

### 3. 边界测试
- [ ] 路径遍历防护（尝试 `../../etc/passwd`）
- [ ] 大文件处理
- [ ] 网络错误处理

## 毕业论文可以讨论的内容

### 1. 架构设计决策
- React Context API vs Redux/Zustand
- 为什么选择Context：轻量、内置、适合中小型应用
- Hooks模式的优势

### 2. 性能优化
- LocalStorage配额管理策略
- Blob URL生命周期管理
- 图片持久化方案对比

### 3. 类型安全
- TypeScript strict mode
- 渐进式类型改进（any → unknown → 具体类型）
- 类型守卫和断言

### 4. 安全实践
- 路径遍历防护
- API密钥存储（可以讨论改进方向：Keychain）
- CSP和沙箱限制

### 5. 重构方法论
- 渐进式重构 vs 完全重写
- 测试先行
- 职责分离原则（SRP）

## 参考资料

- [React Context API文档](https://react.dev/reference/react/createContext)
- [Tauri Security Best Practices](https://tauri.app/v1/guides/features/security/)
- [TypeScript Handbook - Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
- [Refactoring: Improving the Design of Existing Code](https://refactoring.com/)

## 下一步

1. ✅ 测试现有功能是否正常
2. ⏳ 逐步迁移App.tsx使用新的Context和hooks
3. ⏳ 添加单元测试
4. ⏳ 性能profiling和优化
5. ⏳ 撰写毕业论文相关章节
